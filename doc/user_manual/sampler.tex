\section{Samplers}
\label{sec:Samplers}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% If you are confused by the input of this document, please make sure you see
% these defined commands first. There is no point writing the same thing over
% and over and over and over and over again, so these will help us reduce typos,
% by just editing a template sentence or paragraph.
\renewcommand{\nameDescription}
{
  \xmlAttr{name},
  \xmlDesc{required string attribute}, user-defined name of this sampler.
  \nb As with other objects, this identifier can be used to reference this
  specific entity from other input blocks in the XML.
}
\renewcommand{\specBlock}[2]
{
  The specifications of this sampler must be defined within #1 \xmlNode{#2} XML
  block.
}
\newcommand{\variableChildIntro}
{
 This \xmlNode{variable} recognizes the following child node:
}

\newcommand{\variableChildrenIntro}
{
  This \xmlNode{variable} recognizes the following child nodes:
}

\newcommand{\variableIntro}[1]
{
  In the \xmlNode{#1} input block, the user
  needs to specify the variables to sample.
  %
  As already mentioned, these variables are specified within consecutive
  \xmlNode{variable} XML blocks:
}

\newcommand{\constructionGridDescription}
{
Based on the \xmlAttr{construction} type, the content of the \xmlNode{grid}
XML node and the requirements for other attributes change:
\begin{itemize}
  \item \xmlAttr{construction}\textbf{\texttt{=}}\xmlString{equal}.
    The grid is going to be constructed equally-spaced
    (\xmlAttr{type}\textbf{\texttt{=}}\xmlString{value}) or equally probable
    (\xmlAttr{type}\textbf{\texttt{=}}\xmlString{CDF}).
    This construction type requires the definition of additional attributes:
      \begin{itemize}
         \item \xmlAttr{steps}, \xmlDesc{required integer attribute}, number
           of equally spaced/probable discretization steps.
         \item \xmlAttr{upperBound}, \xmlDesc{conditional float attribute}, the
           upper limit of the grid.
           \nb This attribute must be specified if the \xmlAttr{lowerBound}
           has not been defined.
         \item \xmlAttr{lowerBound}, \xmlDesc{conditional float attribute}, the
           lower limit of the grid.
           \nb This attribute must be specified if the \xmlAttr{upperBound}
           has not been defined.
      \end{itemize}
      This construction type requires that the content of the \xmlNode{grid}
      node represents the step size,$stepSize$ in the expression below, (either
      in probability or value).
      The attributes \xmlAttr{lowerBound} and \xmlAttr{upperBound} are
      mutually exclusive (only one of them can be specified):
      \begin{itemize}
      \item If the \xmlAttr{upperBound} is present, the grid lower bound
        will be at:\\
        $\xmlAttr{upperBound} - \xmlAttr{steps}*stepSize$
      \item If the \xmlAttr{lowerBound} is present, the grid upper bound
        will be at:\\
        $\xmlAttr{lowerBound} + \xmlAttr{steps}*stepSize$
      \end{itemize}
      The lower and upper bounds are checked against the associated
      \xmlNode{distribution} bounds.
      If one or both of them falls outside the distribution's bounds, the
      code will raise an error.
  \item \xmlAttr{construction}\textbf{\texttt{=}}\xmlString{custom}.
    The grid will be directly specified by the user.
    No additional attributes are needed.

    This construction type requires that the \xmlNode{grid} node contains
    the actual mesh bins.
    For example, if the grid \xmlAttr{type} is \xmlString{CDF}, in the body
    of \xmlNode{grid}, the user will specify the CDF probability thresholds
    (nodalization in probability).
\end{itemize}
}
\newcommand{\variableDescription}
{
  \xmlNode{variable}, \xmlDesc{XML node,
  required parameter} will specify one attribute:
  \begin{itemize}
    \item \xmlAttr{name}, \xmlDesc{required string attribute}, user-defined name
      of this variable.
  \end{itemize}
}

\newcommand{\distributionDescription}
{
  \xmlNode{distribution}, \xmlDesc{string,
  required field}, name of the distribution that is associated to this variable.
  Its name needs to be contained in the \xmlNode{Distributions} block explained
  in Section \ref{sec:distributions}.
}

\newcommand{\gridDescription}
{
  \xmlNode{grid}, \xmlDesc{float or space separated floats, required
  field}, the content of this XML node depends on the definition of the
  associated attributes:
  \begin{itemize}
  \itemsep0em
    \item \xmlAttr{type}, \xmlDesc{required string attribute}, user-defined
      discretization metric type: 1) \xmlString{CDF}, the grid will be
      specified based on cumulative distribution function probability
      thresholds, and 2) \xmlString{value}, the grid will be provided
      using variable values.
    \item \xmlAttr{construction}, \xmlDesc{required string attribute}, how
      the grid needs to be constructed, independent of its type (i.e.
      \xmlString{CDF} or \xmlString{value}).
  \end{itemize}
  \constructionGridDescription
}

\newcommand{\convergenceDescription}
{
\xmlNode{Convergence}, \xmlDesc{float, required field}, Convergence 
    tolerance.
    %
    The meaning of this tolerance depends on the definition of other attributes
    that might be defined in this XML node:
    \begin{itemize}
      \item \xmlAttr{limit}, \xmlDesc{optional integer attribute}, the
        maximum number of adaptive samples.
        %
        \default{infinite}.
      \item \xmlAttr{forceIteration}, \xmlDesc{optional boolean attribute},
        this attribute controls if at least a number of iterations equal to
        \textbf{limit} must be performed.
        %
        \default{False}.
      \item \xmlAttr{weight}, \xmlDesc{optional string attribute (case insensitive)}, defines on
        what the convergence check needs to be performed.
        \begin{itemize}
          \item \xmlString{CDF}, the convergence is checked in terms
            of probability (Cumulative Distribution Function).
          \item \xmlString{value}, the convergence is checked on the 
            hyper-volume in terms of variable values.
        \end{itemize}
        \default{CDF}.
      \item \xmlAttr{persistence}, \xmlDesc{optional integer attribute}, 
        offers an additional convergence check.
        %
        It represents the number of times the computed error needs to be
        below the inputted tolerance before convergence is reported.
        %
        \default{0}.
     % \item \xmlAttr{subGridTol}, \xmlDesc{optional string attribute}, 
      %  defines a tolerance for constructing a sub-grid on which the
       % acceleration ROM is going to be tested.
        %
       % \default{None}.
    \end{itemize}
    In summary, this XML node contains the information that is needed in order
    to control this sampler's convergence criterion.
}

\newcommand{\assemblerDescription} %%NOTE this only applies to the adaptive sampler.  Why is it a newcommand? %%
{
  \textbf{Assembler Objects} These objects are either required or optional
    depending on the functionality of the Adaptive Sampler.
    %
    The objects must be listed with a rigorous syntax that, except for the XML
    node tag, is common among all the objects.
    %
    Each of these nodes must contain 2 attributes that are used to identify them
    within the simulation framework:
    \begin{itemize}
      \item \xmlAttr{class}, \xmlDesc{required string attribute}, the main
        ``class'' of the listed object.
        %
        For example, it can be \xmlString{Models}, \xmlString{Functions}, etc.
      \item \xmlAttr{type},  \xmlDesc{required string attribute}, the object
        identifier or sub-type.
        %
        For example, it can be \xmlString{ROM}, \xmlString{External}, etc.
    \end{itemize}
    The \textbf{Adaptive Sampler} approach requires or optionally accepts the
    following object types:
    \begin{itemize}
      \item \xmlNode{ROM}, \xmlDesc{, string, optional  field}, if used, the
        body of this XML node must contain the name of a ROM defined in the
        \xmlNode{Models} block (see Section~\ref{subsec:models_ROM}).
      \item \xmlNode{Function}, \xmlDesc{string, required field},  the
        body of this XML block needs to contain the name of an external 
        function object defined within the \xmlNode{Functions} main block (see 
        Section~\ref{sec:functions}).
        %
        This object represents the boolean function that defines the transition
        boundaries.
        %
        This function must implement a method called
        \texttt{\_\_residuumSign(self)}, that returns either -1 or 1, depending
        on the system conditions (see Section \ref{sec:functions}.
      \item \xmlNode{TargetEvaluation}, \xmlDesc{string, required field}, 
        represents the container where the system evaluations are stored.
        %
        From a practical point of view, this XML node must contain the name of
        a data object defined in the \xmlNode{Datas} block (see
        Section~\ref{sec:Datas}).
        %
        The adaptive sampling accepts ``Datas'' of type ``TimePoint'' and
        ``TimePointSet'' only.
    \end{itemize}
}
\newcommand{\assemblerROMDescription}[1]
{
  \textbf{Assembler Objects} These objects are either required or optional
    depending on the functionality of the #1 sampler.
    %
    The objects must be listed with a rigorous syntax that, except for the XML
    node tag, is common among all the objects.
    %
    Each of these nodes must contain 2 attributes that are used to map them
    within the simulation framework:
    \begin{itemize}
      \item \xmlAttr{class}, \xmlDesc{required string attribute}, the main
        ``class'' of the listed object.
        %
        For example, it can be \xmlString{Models}, \xmlString{Functions}, etc.
      \item \xmlAttr{type},  \xmlDesc{required string attribute}, the object
        identifier or sub-type.
        %
        For example, it can be \xmlString{ROM}, \xmlString{External}, etc.
    \end{itemize}
    The \textbf{#1 sampler} requires  the
    following object types:
    \begin{itemize}
      \item \xmlNode{ROM}, \xmlDesc{string, required field}, the
        body of this XML node must contain the name of an appropriate ROM defined in the
        \xmlNode{Models} block (see Section~\ref{subsec:models_ROM}).
    \end{itemize}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The sampler is probably the most important entity in the RAVEN framework.
%
It performs the driving of the specific sampling strategy and, hence, determines
the effectiveness of the analysis, from both an accuracy and computational point
of view.
%
The samplers, that are available in RAVEN, can be categorized into three main
classes:
\begin{itemize}
\item \textbf{Once-through} (see Section~\ref{subsec:onceThroughSamplers})
\item \textbf{Dynamic Event Tree (DET)} (see Section~\ref{subsec:DETSamplers})
\item \textbf{Adaptive} (see Section~\ref{subsec:AdaptSamplers})
\end{itemize}
Before analyzing each sampler in detail, it is important to mention that each
type has a similar syntax to input the variables to be ``sampled''.
%
In the example below, the variable \xmlString{variableName} is going to be
sampled by the Sampler \xmlString{whatever} using the distribution named\\
\xmlString{aDistribution}.
\begin{lstlisting}[style=XML]
<Simulation>
  ...
  <Samplers>
    ...
    <WhatEverSampler name='whatever'>
      ...
     <variable name='variableName'>
       ...
       <distribution>aDistribution</distribution>
       ...
     </variable>
      ...
    </WhatEverSampler>
    ...
  </Samplers>
  ...
</Simulation>
\end{lstlisting}

As reported in section \ref{sec:existingInterface}, the variable naming syntax,
for external driven codes, depends on the way the ``code interface'' has been
implemented.
%
For example, if the code has an input structure like the one reported below (YAML), the
variable name might be\xmlString{I-Level|II-Level|variable}.
%
In this way, the relative code interface (and input parser) will know which
variable needs to be perturbed and the ``recipe'' to access it.
%
As reported in \ref{sec:existingInterface}, its syntax is chosen by the
developer of the ``code interface'' and is implemented in the interface only
(no modifications are needed in the RAVEN code).

%\maljdan{Where does this type of input come from? Should the user care?}
%\alfoa{Dan, this is an example (in this case, a YAML structure)}

Example YAML based Input:
\begin{lstlisting}
[I-Level]
  [./II-Level]
    variable = xxx
  [../]
[]
\end{lstlisting}

Example XML block to define the variables and associated distributions:
\begin{lstlisting}[style=XML]
<variable name='I-Level|II-Level|variable'>
  <distribution>exampleDistribution</distribution>
</variable>
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Once-Through Samplers %%%
%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Once-through Samplers}
\label{subsec:onceThroughSamplers}
The once-through sampler category collects all the strategies that perform the
sampling of the input space without exploiting, through dynamic learning
approaches, the information made available from the outcomes of calculations
previously performed (adaptive sampling) and the common system evolution
(patterns) that different sampled calculations can generate in the phase space
(dynamic event tree).
%
In the RAVEN framework, five different “once-through” samplers
are available:
\begin{itemize}
\item \textbf{Monte Carlo (MC)}
\item \textbf{Stratified}
\item \textbf{Grid Based}
\item \textbf{Sparse Grid Collocation}
\item \textbf{Response Surface Design of Experiment}
\item \textbf{Factorial Design of Experiment}
\end{itemize}

From a practical point of view, these sampling strategies represent different
ways to explore the input space.
%
In the following paragraphs, the input requirements and a small explanation of
the different sampling methodologies are reported.

%%% Once-Through Samplers: MonteCarlo
\subsubsection{Monte Carlo}
\label{subsubsubsec:MC}
The \textbf{Monte-Carlo} sampling approach is one of the most well-known and
widely used approaches to perform exploration of the input space.
%
The main idea behind MonteCarlo sampling is to  randomly perturbate of the input space according
to uniform or parameter-based probability density functions.
%

\specBlock{a}{MonteCarlo}
%
\attrsIntro
\vspace{-5mm}
\begin{itemize}
\itemsep0em
\item \textbf{name}, \textit{required string attribute}, user-defined name of this Sampler. N.B. As for the other objects, this is the name that can be used to refer to this specific entity from other input blocks (xml);
%\item \textbf{limit}, \textit{required integer attribute}, number of MonteCarlo samples needs to be generated;
%\item \textbf{initial\_seed}, \textit{optional integer attribute}, initial seeding of random number generator. \textit{Default = random seed};
%\item \textbf{reseedAtEachIteration}, \textit{optional boolean/string attribute}, perform a re-seeding for each sample generated (True values = True, yes, y, t). \textit{Default = False}; 
\end{itemize}
\vspace{-5mm}

In the \textbf{MonteCarlo} input block, the user needs to specify the variables need to be sampled. As already mentioned, these variables are inputted within consecutive xml blocks called $<variable>$:
\begin{itemize}
\item $<sampler\textunderscore init>$, xml node, required parameter. In this xml-node,the following xml-nodes need to be specified:
  \begin{itemize}
    \item \textbf{limit}, \textit{required string attribute}, number of MonteCarlo samples needs to be generated; 
    \item \textbf{initial\textunderscore seed}, \textit{optional integer attribute}, initial seeding of random number generator
    \item \textbf{reseed\_at\_each\_iteration}, \textit{optional boolean/string attribute (case insensitive)}, perform a re-seeding for each sample generated (True values = True, yes, y, t). \textit{Default = False}; 
    \item \textbf{dist\textunderscore init}, \textit{optional xml node}, in this node the user specifies the initialization of the random number generator function for each N-Dimensional Probability Distributions (see Section~\ref{subsec:NdDist}). 
  \end{itemize}
\item $<variable>$, xml node, required parameter. This xml-node needs to contain the attribute:
% =======
% \item \nameDescription
% \item \xmlAttr{limit}, \xmlDesc{required integer attribute}, number of
%   Monte-Carlo samples to be generate.
% \item \xmlAttr{initial\_seed}, \xmlDesc{optional integer attribute}, initial
%   seeding of random number generator.
%   \default{random seed}.
% \item \xmlAttr{reseedAtEachIteration}, \xmlDesc{optional boolean/string
%   attribute}, perform a re-seeding for each sample generated
%   (True values = True, yes, y, t).
%   \default{False}.
% \end{itemize}
% \vspace{-5mm}
% \variableIntro{MonteCarlo}
% >>>>>>> origin/devel
\begin{itemize}
\item \variableDescription
 \variableChildIntro
 \begin{itemize}
    \item \distributionDescription
  \end{itemize}
\end{itemize}
\end{itemize}

Example:
\begin{lstlisting}[style=XML]
<Samplers>
  ...
  <MonteCarlo name='MCname'> 
    <sampler_init>
      <limit>10</limit>
      <initial_seed>200286</initial_seed>
      <reseed_at_each_iteration>false</reseed_at_each_iteration>
      <dist_init>
        <distribution name= 'ND_InverseWeight_P'>
          <initial_grid_disc>10</initial_grid_disc>
          <tolerance>0.2</tolerance>
        </distribution>
      </dist_init>
    </sampler_init>
    <variable name='var1'> 
      <distribution>aDistributionNameDefinedInDistributionBlock
      </distribution>  
    </variable> 
  </MonteCarlo>
  ...
</Samplers>
\end{lstlisting}

%%% Once-Through Samplers: Grid
\subsubsection{Grid}
\label{subsubsubsec:Grid}
The \textbf{Grid} sampling approach is probably the simplest exploration
approach that can be employed to explore an uncertain domain.
%
The idea is to construct an $N$-dimensional grid where each dimension is
represented by one uncertain variable.
%
This approach performs the sampling at each node of the grid.
%
The sampling of the grid consists in evaluating the answer of the system under
all possible combinations among the different variables' values with respect to
a predefined discretization metric.
%
In RAVEN two discretization metrics are available: 1) cumulative distribution
function, and 2) value.
%
Thus, the grid meshing can be input via probability or variable values.
%
Regarding the N-dimensional distributions, the user can specify for each dimension the type of grid to be used (i.e., value or CDF). Note the discretization of the CDF, only for the grid sampler, is performed on the marginal distribution for the specific variable considered.

\specBlock{a}{Grid}
%
\attrIntro
\begin{itemize}
\itemsep0em
\item \nameDescription
\end{itemize}
\variableIntro{Grid}
\begin{itemize}
\item \variableDescription
 \variableChildrenIntro
 \begin{itemize}
    \item \distributionDescription
    \item \gridDescription
  \end{itemize}
\end{itemize}

Example:
\begin{lstlisting}[style=XML,morekeywords={construction,steps,lowerBound,upperBound}]
<Samplers>
  ...
  <Grid name='Gridname'> 
    <variable name='var1'> 
      <distribution>aDistributionNameDefinedInDistributionBlock1
      </distribution> 
      <grid type='value' construction='equal' steps='100' lowerBound='1.0'>0.2</grid> 
    </variable> 
    <variable name='var2'> 
      <distribution>aDistributionNameDefinedInDistributionBlock2
      </distribution> 
      <grid type='CDF' construction='equal' steps='5' lowerBound='0.0'>0.2</grid> 
    </variable>
    <variable name='var3'> 
      <distribution>aDistributionNameDefinedInDistributionBlock3
      </distribution> 
      <grid type='value' construction='equal' steps='100' upperBound='21.0'>0.2</grid> 
    </variable> 
    <variable name='var4'> 
      <distribution>aDistributionNameDefinedInDistributionBlock4
      </distribution> 
      <grid type='CDF' construction='equal' steps='5' upperBound='1.0'>0.2</grid> 
    </variable>
    <variable name='var5'> 
      <distribution>aDistributionNameDefinedInDistributionBlock5
      </distribution> 
      <grid type='value' construction='custom'>0.2 0.5 10.0</grid> 
    </variable> 
    <variable name='var6'> 
      <distribution>aDistributionNameDefinedInDistributionBlock6
      </distribution> 
      <grid type='CDF' construction='custom'>0.2 0.5 1.0</grid> 
    </variable>
  </Grid>
  ...
</Samplers>
\end{lstlisting}

%%% Once-Through Samplers: Sparse Grid Collocation
\subsubsection{Sparse Grid Collocation}
%\talbpaul{Work in progress.}
%\senrs{Assembler section updated}
\label{subsubsubsec:SparseGridCollocation}
\textbf{Sparse Grid Collocation} builds on generic \textbf{Grid} sampling by selecting evaluation points based on characteristic quadratures as part of stochastic collocation for generalized polynomial chaos uncertainty quantification.  In collocation you construct an N-dimensional grid, with each uncertain variable providing an axis.  Along each axis, the points of evaluation correspond to quadrature points necessary to integrate polynomials (see \ref{subsubsec:GaussPolynomialRom}).  In the simplest (and most  naive) case, a N-Dimensional tensor product of all possible combinations of points from each dimension's quadrature is constructed as sampling points.  The number of necessary samples can be reduced by employing Smolyak-like sparse grid algorithms, which use reduced combinations of polynomial orders to reduce the necessary sampling space.  \specBlock{a}{SparseGridCollocation}.
\begin{itemize}
\itemsep0em
\item \nameDescription
\item \xmlAttr{parallel}, \xmlDesc{optional string attribute}, option to disable parallel construction of the sparse grid.  Because of increasing computational expense with increasing input space dimension, RAVEN will default to parallel construction of the sparse grid. %\talbpaul{Is this what we want?} 
\default{True}
\end{itemize}
\variableIntro{SparseGridCollocation}
\begin{itemize}
\item \variableDescription
 In the variable node, the following xml-node needs to be specified:
 \begin{itemize}
    \item \distributionDescription
 \end{itemize} \end{itemize}
Because of the tight coupling between the Sampler and the ROM in stochastic collocation for generalized polynomial chaos, the Sampler needs access to the ROM via the assembler do determine the polynomials, quadratures, and importance weights to use in each dimension (see \ref{subsubsec:GaussPolynomialRom}).
\begin{itemize}

  % Assembler Objects
  \item \assemblerROMDescription{SparseGridCollocation}

    The \textbf{SparseGridCollocation} sampler also optionally accepts  the
    following object types:
    \begin{itemize}
      \item \xmlNode{Restart}, \xmlDesc{string, optional field}, the
        body of this XML node must contain the name of an appropriate TimePointSet defined in the
        \xmlNode{Datas} block (see Section~\ref{subsec:models_ROM}).  It is used as a
        ``restart'' tool, where it accepts pre-existing solutions in the TimePointSet instead
        of recalculating solutions.
    \end{itemize}
  \end{itemize}
\footnotesize
\begin{lstlisting}[style=XML]
Example:
<Samplers>
  ...
  <SparseGridCollocation name="mySG" parallel="0">
    <variable name="x1">
      <distribution>myDist1</distribution>
    </variable>
    <variable name="x2">
      <distribution>myDist2</distribution>
    </variable>
    <ROM class = 'Models' type = 'ROM' >SCROM</ROM>
    <Restart class = 'Datas' type = 'TimePointSet' >solns</Restart>
  </SparseGridCollocation>
  ...
</Samplers>
\end{lstlisting}
 \normalsize
 
 %%% Once-Through Samplers: Sobol
\subsubsection{Sobol}
%\senrs{Assembler section updated}
\label{subsubsubsec:SobolSampler}
The \textbf{Sobol} sampler uses high-density model reduction (HDMR) a.k.a. Sobol decomposition to approximate a function as the sum of increasing-complexity interactions.  At its lowest level (order 1), it treats the function as a sum of the reference case plus a functional of each input dimesion separately.  At order 2, it adds functionals to consider the pairing of each dimension with each other dimension.  The benefit to this approach is considering several functions of small input cardinality instead of a single function with large input cardinality.  This allows reduced order models like generalized polynomial chaos (see \ref{subsubsec:GaussPolynomialRom}) to approximate the functionals accurately with few computations runs.  This Sobol sampler uses the associated HDMRRom (see \ref{subsubsec:HDMRRom}) to determine at what points the input space need be evaluated.
\begin{itemize}
\itemsep0em
\item \nameDescription
\item \xmlAttr{parallel}, \xmlDesc{optional string attribute}, option to disable parallel construction of the sparse grid.  Because of increasing computational expense with increasing input space dimension, RAVEN will default to parallel construction of the sparse grid.
\default{True}
\end{itemize}
\variableIntro{Sobol}
\begin{itemize}
\item \variableDescription
 In the variable node, the following xml-node needs to be specified:
 \begin{itemize}
    \item \distributionDescription
 \end{itemize} \end{itemize}
Because of the tight coupling between the Sobol sampler and the HDMRRom, the Sampler needs access to the ROM via the assembler do determine the polynomials, quadratures, Sobol order, and importance weights to use in each dimension (see \ref{subsubsec:HDMRRom}).  
\begin{itemize}

  % Assembler Objects
  \item \assemblerROMDescription{Sobol}

\end{itemize}
\footnotesize
\begin{lstlisting}[style=XML]
Example:
<Samplers>
  ...
  <Sobol name="mySobol" parallel="0">
    <variable name="x1">
      <distribution>myDist1</distribution>
    </variable>
    <variable name="x2">
      <distribution>myDist2</distribution>
    </variable>
    <ROM class = 'Models' type = 'ROM' >myHDMR</ROM>
  </Sobol>
  ...
</Samplers>
\end{lstlisting}
 \normalsize
 
%%% Once-Through Samplers: Stratified
\subsubsection{Stratified}
\label{subsubsubsec:Stratified}
The \textbf{Stratified} sampling approach is a method for the exploration of the
input space that consists of dividing the uncertain domain into subgroups before
sampling.
%
In the ``stratified'' sampling, these subgroups must be:
\begin{itemize}
 \item mutually exclusive: every element in the population must be assigned to
   only one stratum (subgroup);
 \item collectively exhaustive: no population element can be excluded.
\end{itemize}

Then simple random sampling or systematic sampling is applied within each
stratum.
%
It is worthwhile to note that the well-known Latin hypercube sampling represents
a specialized version of the stratified approach, when the domain strata are
constructed in equally-probable CDF bins.

\specBlock{a}{Stratified}
%
\attrIntro
\begin{itemize}
\itemsep0em
\item \nameDescription
\end{itemize}
\variableIntro{Stratified}
\begin{itemize}
\item \variableDescription
 \variableChildrenIntro
 \begin{itemize}
    \item \distributionDescription
    \item \gridDescription
  \end{itemize}
\end{itemize}

As one can see, the input specifications for the \textbf{Stratified} sampler are
similar to that of the \textbf{Grid} sampler.
%
It is important to mention again that for each zone (grid mesh) only a point,
randomly selected, is picked and not all the nodal combinations (like in the
\textbf{Grid} sampling).

Example:
\begin{lstlisting}[style=XML,morekeywords={construction,steps,lowerBound,upperBound}]
<Samplers>
  ...
  <Stratified name='StratifiedName'> 
    <variable name='var1'> 
      <distribution>aDistributionNameDefinedInDistributionBlock1
      </distribution> 
      <grid type='CDF' construction='equal' steps='5' lowerBound='0.0'>0.2</grid> 
    </variable>
    <variable name='var2'> 
      <distribution>aDistributionNameDefinedInDistributionBlock2
      </distribution> 
      <grid type='value' construction='equal' steps='100' upperBound='21.0'>0.2</grid> 
    </variable> 
    <variable name='var3'> 
      <distribution>aDistributionNameDefinedInDistributionBlock3
      </distribution> 
      <grid type='CDF' construction='custom'>0.2 0.5 1.0</grid> 
    </variable>
  </Stratified>
  ...
</Samplers>
\end{lstlisting}

For N-dimensional  (ND) distributions, when the sampling is performed on a grid on a CDF  the user it is required to specify the same CDF grid for all the dimensions of the ND distribution.
This is possible by defining a global\_grid and associate such global grid to each variable belonging to the ND distribution as follows.

\begin{lstlisting}[style=XML,morekeywords={ND,grid}]
<Samplers>
  ...
  <LHS name='StratifiedName'> 
        <variable name='x0'>
            <distribution dim='1'>ND_InverseWeight_P</distribution>
            <grid type='global_grid'>name_grid1</grid>
        </variable>
        <variable name='y0,z0'>
            <distribution dim='2'>ND_InverseWeight_P</distribution>
            <grid type='global_grid'>name_grid1</grid>
        </variable>
        <global_grid>
            <grid name='name_grid1' construction='custom'>0.1 1.0 0.2</grid>
        </global_grid>
  </LHS>
  ...
</Samplers>
\end{lstlisting}

%%% Once-Through Samplers: Response Surface Design
\subsubsection{Response Surface Design}
\label{subsubsubsec:RespSurfDOE}
The \textbf{Response Surface Design}, or Response Surface Modeling (RSM), 
approach is one of the most common Design of Experiment (DOE) methodologies
currently in use.
%
It explores the relationships between several explanatory variables and one or
more response variables.
%
The main idea of RSM is to use a sequence of designed experiments to obtain an
optimal response.
%
RAVEN currently employs two different algorithms that can be classified within
this family of methods:
\begin{itemize}
 \item \textbf{Box-Behnken}: This methodology aims to achieve the following
  goals:
  \begin{itemize}
    \item Each factor, or independent variable, is placed at one of three
      equally spaced values, usually coded as -1, 0, +1. (At least three levels
      are needed for the following goal);
    \item The design should be sufficient to fit a quadratic model, that is, one
      squared term per factor and the products of any two factors;
    \item The ratio of the number of experimental points to the number of
      coefficients in the quadratic model should be reasonable (in fact, their
      designs keep it in the range of 1.5 to 2.6);
    \item The estimation variance should more or less depend only on the
      distance from the center (this is achieved exactly for the designs with 4
      and 7 factors), and should not vary too much inside the smallest
      (hyper)cube containing the experimental points.
  \end{itemize}
  Each design can be thought of as a combination of a two-level (full or
  fractional) factorial design with an incomplete block design.
  In each block, a certain number of factors are put through all combinations
  for the factorial design, while the other factors are kept at the central
  values.
 \item \textbf{Central Composite}: This design consists of three distinct sets
  of experimental runs:
  \begin{itemize}
    \item A factorial (perhaps fractional) design in the factors are studied,
      each having two levels;
    \item A set of center points, experimental runs whose values of each factor
      are the medians of the values used in the factorial portion.
      This point is often replicated in order to improve the precision of the
      experiment;
    \item A set of axial points, experimental runs identical to the centre
      points except for one factor, which will take on values both below and
      above the median of the two factorial levels, and typically both outside
      their range.
      All factors are varied in this way.
  \end{itemize}
  This methodology is useful for building a second order (quadratic) model for
  the response variable without needing to use a complete three-level factorial
  experiment.
\end{itemize}
All the parameters, needed for setting up the algorithms reported above, must be
defined within a \xmlNode{ResponseSurfaceDesign} block.
%
\attrIntro
\begin{itemize}
\itemsep0em
\item \nameDescription
\end{itemize}

\variableIntro{ResponseSurfaceDesign}
\begin{itemize}
\item \variableDescription
 \variableChildrenIntro
 \begin{itemize}
    \item \distributionDescription
     \item \xmlNode{boundaries}, \xmlDesc{XML node, required field}, within this
       block the boundaries for this variable are defined.
       This XML node needs to contain the attribute:
       \begin{itemize}
         \item \xmlAttr{type}, \xmlDesc{required string attribute}, how the
           boundaries are defined.
           This attribute can be:
           \begin{itemize}
             \item \xmlString{CDF}: the boundaries are going to be provided as
               probability CDF thresholds
             \item \xmlString{value}: the boundaries are going to be provided as
               variable values.
           \end{itemize}
       \end{itemize}
       Within the \xmlNode{boundaries} block, the following sub-nodes need to be
       provided:
       \begin{itemize}
         \item \xmlNode{lower}, \xmlDesc{float, required field}, the lower limit
           of this variable.
         \item \xmlNode{upper}, \xmlDesc{float, required field}, the upper limit
           of this variable.
       \end{itemize}
 \end{itemize}
\end{itemize}
The main XML block \xmlNode{ResponseSurfaceDesign} needs to contain an
additional sub-node called \xmlNode{ResponseSurfaceDesignSettings}. 
In this sub-node, the user needs to specify different settings depending on the
algorithm being used:
     \begin{itemize}
      \item \xmlNode{algorithm\_type}, \xmlDesc{string, required field}, this XML node
        will contain the name of the algorithm to be used.
        Based on the chosen algorithm, other nodes need to be defined:
        \begin{itemize}
          \item \xmlNode{algorithm\_type}\texttt{BoxBehnken}\xmlNode{algorithm\_type/}. If Box-Behnken
            is specified, the following additional node is recognized:
         \begin{itemize}
          \item \xmlNode{ncenters}, \xmlDesc{integer, optional field}, the
            number of center points to include in the box.
            If this parameter is not specified, then a pre-determined number of
            points are automatically included.
            \default{Automatic Generation}.
         \end{itemize}
         \nb In order to employ the ``Box-Behnken'' design, at least 3 variables
         must be used.
         \item \xmlNode{algorithm\_type}\texttt{CentralComposite}\xmlNode{algorithm\_type/}. If
           Central Composite is specified, the following additional nodes will
           be recognized:
         \begin{itemize}
          \item \xmlNode{centers}, \xmlDesc{comma separated integers, optional
            field}, the number of center points to be included.
            This block needs to contain 2 integers values separated by a comma.
            The first entry represents the number of centers to be added for the
            factorial block; the second one is the one for the star block.
            \default{4,4}.
          \item \xmlNode{alpha}, \xmlDesc{string, optional field}, in this node,
            the user decides how an $\alpha$ factor needs to be determined.
            Two options are available:
            \begin{itemize}
              \item \texttt{orthogonal}, for orthogonal design.
              \item \texttt{rotatable}, for rotatable design.
            \end{itemize}
            \default{orthogonal}.
          \item \xmlNode{face}, \xmlDesc{string, optional field}, in this node,
            the user defines how faces should be constructed.
            Three options are available:
            \begin{itemize}
              \item \texttt{circumscribed}, for circumscribed facing
              \item \texttt{inscribed}, for inscribed facing
              \item \texttt{faced}, for faced facing.
            \end{itemize}
            \default{circumscribed}.
         \end{itemize}
      \end{itemize}
      \nb In order to employ the ``Central Composite'' design, at least 2
      variables must be used.
    \end{itemize}

%\maljdan{Is it weird that one of these uses ncenters and the other uses centers?}
%\alfoa{The names of those parameters are different in order to avoid confusion, since the meaning (and the way ) to input them is different}

%\maljdan{This is the first example where type is an attribute and a node...This
%is confusing.}
%\alfoa{Changed.}

Example:
\begin{lstlisting}[style=XML,morekeywords={}]
<Samplers>
  ...
    <ResponseSurfaceDesign name='BoxBehnkenRespDesign'>
        <ResponseSurfaceDesignSettings>
            <algorithm_type>BoxBehnken</algorithm_type>
            <ncenters>1</ncenters>
        </ResponseSurfaceDesignSettings>
        <variable name='var1' >
            <distribution >Gauss1</distribution>
            <boundaries type="CDF">
                <lower>0.0</lower>
                <upper>1.0</upper>
            </boundaries>
        </variable>
        <!-- N.B. at least 3 variables need to inputted 
                in order to employ this algorithm
         -->
    </ResponseSurfaceDesign>
    <ResponseSurfaceDesign name='CentralCompositeRespDesign'>
        <ResponseSurfaceDesignSettings>
            <algorithm_type>CentralComposite</algorithm_type>
            <centers>1, 2</centers>
            <alpha>orthogonal</alpha>
            <face>circumscribed</face>
        </ResponseSurfaceDesignSettings>
        <variable name='var4' >
            <distribution >Gauss1</distribution>
            <boundaries type="CDF">
                <lower>aFloatValue</lower>
                <upper>aFloatValue</upper>
            </boundaries>
        </variable>
        <!-- N.B. at least 2 variables need to inputted 
                in order to employ this algorithm
         -->        
    </ResponseSurfaceDesign>
  ...
</Samplers>
\end{lstlisting}

%%% Once-Through Samplers: Factorial Design
\subsubsection{Factorial Design}
\label{subsubsubsec:FactorialDOE}
The \textbf{Factorial Design} method is an important method to determine the
effects of multiple variables on a response.
%
A factorial design can reduce the number of samples one has to perform by
studying multiple factors simultaneously.
%
Additionally, it can be used to find both main effects (from each independent
factor) and interaction effects (when both factors must be used to explain the
outcome).
%
A factorial design tests all possible conditions.
%
Because factorial designs can lead to a large number of trials, which can
become expensive and time-consuming, they are best used for small numbers of
variables with only a few domain discretizations (1 to 3).
%
Factorial designs work well when interactions between variables are strong and
important and where every variable contributes significantly.
%
RAVEN currently employs three different algorithms that can be classified within
this family of techniques:
\begin{itemize}
  \item \textbf{General Full Factorial} explores the input space by
    investigating all possible combinations of a set of factors (variables).
  \item \textbf{2-Level Fractional-Factorial} consists of a carefully chosen
    subset (fraction) of the experimental runs of a full factorial design.
    %
    The subset is chosen so as to exploit the sparsity-of-effects principle 
    exposing information about the most important features of the problem
    studied, while using a fraction of the effort of a full factorial design in
    terms of experimental runs and resources.
  \item \textbf{Plackett-Burman} identifies the most important factors early in
    the experimentation phase when complete knowledge about the system is
    usually unavailable.
    %
    It is an efficient screening method for identifying the active factors
    (variables) using as few samples as possible.
    %
    In Plackett-Burman designs, main effects have a complicated confounding
    relationship with two-factor interactions.
    %
    Therefore, these designs should be used to study main effects when it can be
    assumed that two-way interactions are negligible.
\end{itemize}
All the parameters needed for setting up the algorithms reported above must be
defined within a \xmlNode{FactorialDesign} block.
%
\attrIntro
\begin{itemize}
\itemsep0em
\item \nameDescription
\end{itemize}
\variableIntro{FactorialDesign}
\begin{itemize}
  \item \variableDescription
    \variableChildrenIntro
    \begin{itemize}
      \item \distributionDescription
      \item \gridDescription
    \end{itemize}
\end{itemize}

The main \xmlNode{FactorialDesign} block needs to contain an additional sub-node
called\\\xmlNode{FactorialSettings}.
%
In this sub-node, the user needs to specify different settings depending on the
algorithm being used:
   \begin{itemize}
    \item \xmlNode{algorithm\_type}, \xmlDesc{string, required field}, specifies the
      algorithm to be used.
      %
      Based on the chosen algorithm, other nodes may be defined:
      \begin{itemize}
        \item \xmlNode{algorithm\_type}\texttt{full}\xmlNode{algorithm\_type/}. Full factorial design.
          If \texttt{full} is specified, no additional nodes are necessary.
          \\
          \nb The full factorial design does not have any limitations on the
          number of discretization bins that can be used in the \xmlNode{grid}
          XML node for each \xmlNode{variable} specified.
        \item \xmlNode{algorithm\_type}\texttt{2levelFract}\xmlNode{algorithm\_type/}. Two-level
          Fractional-Factorial design.
          %
          If \\\texttt{2levelFract}  is specified, the following additional
          nodes must be specified:
          \begin{itemize}
            \item \xmlNode{gen}, \xmlDesc{space separated strings, required
              field}, specifies the confounding mapping.
              %
              For instance, in this block the user defines the decisions on a
              fraction of the full-factorial by allowing some of the factor main
              effects to be compounded with other factor interaction effects.
              %\maljdan{compounded?} \alfoa{Right Dan.}
              %
              This is done by defining an alias structure that defines,
              symbolically, these interactions.
              %
              These alias structures are written like “C = AB” or “I = ABC”, or
              “AB = CD”, etc.
              %
              These define how a column is related to the others.
            \item \xmlNode{genMap}, \xmlDesc{space separated strings, required
              field}, defines the mapping between the \xmlNode{gen} symbolic
              aliases and the variables that have been inputted in the
              \xmlNode{FactorialDesign} main block.
          \end{itemize}
          \nb The Two-levels Fractional-Factorial design is limited to 2
          discretization bins in the \xmlNode{grid} node for each
          \xmlNode{variable}.
       \item \xmlNode{algorithm\_type}\texttt{pb}\xmlNode{algorithm\_type/}. Plackett-Burman design.
         If \texttt{pb} is specified, no additional nodes are necessary.
         \\ 
         \nb The Plackett-Burman design does not have any limitations on the
         number of discretization bins allowed in the \xmlNode{grid} node for
         each \xmlNode{variable}.
      \end{itemize}
   
  \end{itemize}
Example:
\begin{lstlisting}[style=XML,morekeywords={construction,upperBound,steps}]
<Samplers>
  ...
  <FactorialDesign name='fullFactorial'>
    <FactorialSettings>
      <algorithm_type>full</algorithm_type>
    </FactorialSettings>
    <variable name='var1' >
      <distribution>aDistributionNameDefinedInDistributionBlock1
      </distribution> 
      <grid type='value' construction='custom' >0.02 0.03 0.5</grid>
    </variable>
    <variable name='var2' >
      <distribution>aDistributionNameDefinedInDistributionBlock2
      </distribution> 
      <grid type='CDF' construction='custom'>0.5 0.7 1.0</grid>
    </variable>
  </FactorialDesign>
  <FactorialDesign name='2levelFractFactorial'>
    <FactorialSettings>
      <algorithm_type>2levelFract</algorithm_type>
      <gen>a,b,ab</gen>
      <genMap>var1,var2,var3</genMap>
    </FactorialSettings>
    <variable name='var1' >
      <distribution>aDistributionNameDefinedInDistributionBlock3
      </distribution> 
      <grid type='value' construction='custom' >0.02 0.5</grid>
    </variable>
    <variable name='var2' >
      <distribution>aDistributionNameDefinedInDistributionBlock
      </distribution> 
      <grid type='CDF' construction='custom'>0.5 1.0</grid>
    </variable>
    <variable name='var3'>
      <distribution>aDistributionNameDefinedInDistributionBlock5
      </distribution> 
      <grid type='value' upperBound='4' construction='equal' steps='1'>0.5</grid>
    </variable>
  </FactorialDesign>
  <FactorialDesign name='pbFactorial'>
    <FactorialSettings>
      <algorithm_type>pb</algorithm_type>
    </FactorialSettings>
    <variable name='var1' >
      <distribution>aDistributionNameDefinedInDistributionBlock6
      </distribution> 
      <grid type='value' construction='custom' >0.02 0.5</grid>
    </variable>
    <variable name='VarGauss2' >
      <distribution>aDistributionNameDefinedInDistributionBlock7
      </distribution> 
      <grid type='CDF' construction='custom'>0.5 1.0</grid>
    </variable>
  </FactorialDesign>
  ...
</Samplers>
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Dynamic Event Tree Samplers %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Dynamic Event Tree (DET) Samplers}
\label{subsec:DETSamplers}
The \textbf{Dynamic Event Tree} methodologies are designed to take the timing of
events explicitly into account, which can become very important especially when
uncertainties in complex phenomena are considered.
%
Hence, the main idea of this methodology is to let a system code determine the
pathway of an accident scenario within a probabilistic environment.
%
In this family of methods, a continuous monitoring of the system evolution in
the phase space is needed.
%
In order to use the DET-based methods, the generic driven code needs to have, at
least, an internal trigger system and, consequently, a ``restart'' capability.
%
In the RAVEN framework, three different DET samplers are available:
\begin{itemize}
\item \textbf{Dynamic Event Tree (DET)}
\item \textbf{Hybrid Dynamic Event Tree (HDET)}
\item \textbf{Adaptive Dynamic Event Tree (ADET)}
\end{itemize}

The ADET methodology represents a hybrid between the DET and adaptive sampling
approaches.
%
For this reason, its input requirements are reported in the Adaptive Samplers'
section (\ref{subsec:AdaptSamplers}).

%%%%%%%%% Dynamic Event Tree Samplers: Dynamic Event Tree
\subsubsection{Dynamic Event Tree}
\label{subsubsubsec:DET}
The \textbf{Dynamic Event Tree} sampling approach is a sampling strategy that is
designed to take the timing of events, in transient/accident scenarios,
explicitly into account.
%
From an application point of view, an $N$-Dimensional grid is built on the CDF
space.
%
A single simulation is spawned and a set of triggers is added to the system code
control logic.
%
Every time a trigger is activated (one of the CDF thresholds in the grid is
exceeded), a new set of simulations (branches) is spawned.
%
Each branch carries its conditional probability.
%
In the RAVEN code, the triggers are defined by specifying a grid using a
predefined discretization metric in the mode input space.
%
RAVEN provides two discretization metrics: 1) CDF, and 2) value.
%
Thus, the trigger thresholds can be entered either in probability or value
space.
%

\specBlock{a}{DynamicEventTree}
%
\attrsIntro
\begin{itemize}
  \itemsep0em
  \item \nameDescription
  \item \xmlAttr{print\_end\_XML}, \xmlDesc{optional string/boolean attribute},
    controls the dumping of a ``summary'' of the DET performed into an external
    XML.
    %
    \default{False}.
  \item \xmlAttr{maxSimulationTime}, \xmlDesc{optional float attribute}, this
    attribute controls the maximum ``mission'' time of the simulation
    underneath.
    %
    \default{None}.
\end{itemize}
\variableIntro{DynamicEventTree}
\begin{itemize}
\item \variableDescription
  \variableChildrenIntro
  \begin{itemize}
    \item \distributionDescription
    \item \gridDescription
  \end{itemize}
\end{itemize}

Example:
\begin{lstlisting}[style=XML]
<Samplers>
  ...
  <DynamicEventTree name='DETname'> 
    <variable name='var1'> 
      <distribution>aDistributionNameDefinedInDistributionBlock1 </distribution> 
      <grid type='value' construction='equal' steps='100' lowerBound='1.0'>0.2</grid> 
    </variable> 
    <variable name='var2'> 
      <distribution>aDistributionNameDefinedInDistributionBlock2 </distribution> 
      <grid type='CDF' construction='equal' steps='5' lowerBound='0.0'>0.2</grid> 
    </variable>
    <variable name='var3'> 
      <distribution>aDistributionNameDefinedInDistributionBlock3 </distribution> 
      <grid type='value' construction='equal' steps='100' upperBound='21.0'>0.2</grid> 
    </variable> 
    <variable name='var4'> 
      <distribution>aDistributionNameDefinedInDistributionBlock4 </distribution> 
      <grid type='CDF' construction='equal' steps='5' upperBound='1.0'>0.2</grid> 
    </variable>
    <variable name='var5'> 
      <distribution>aDistributionNameDefinedInDistributionBlock5 </distribution> 
      <grid type='value' construction='custom'>0.2 0.5 10.0</grid> 
    </variable> 
    <variable name='var6'> 
      <distribution>aDistributionNameDefinedInDistributionBlock6 </distribution> 
      <grid type='CDF' construction='custom'>0.2 0.5 1.0</grid> 
    </variable>
  </DynamicEventTree>
  ...
</Samplers>
\end{lstlisting}

%%%%%%%%% Dynamic Event Tree Samplers: Hybrid Dynamic Event Tree
\subsubsection{Hybrid Dynamic Event Tree}
\label{subsubsubsec:HDET}
The \textbf{Hybrid Dynamic Event Tree} sampling approach is a sampling strategy
that represents an evolution of the Dynamic Event Tree method for the
simultaneous exploration of the epistemic and aleatory uncertain space.
%
In similar approaches, the uncertainties are generally treated by employing a
Monte-Carlo sampling approach (epistemic) and DET methodology (aleatory).
%
The HDET methodology, developed within the RAVEN code, can reproduce the
capabilities employed by this approach, but provides additional sampling
strategies to the user.
%
The epistemic or epistemic-like uncertainties can be sampled through the
following strategies:

\begin{itemize}
  \item Monte-Carlo;
  \item Grid sampling;
  \item Stratified (e.g., Latin Hyper Cube).
\end{itemize}

From a practical point of view, the user defines the parameters that need to be
sampled by one or more different approaches.
%
The HDET module samples those parameters creating an $N$-dimensional grid
characterized by all the possible combinations of the input space coordinates
coming from the different sampling strategies.
%
Each coordinate in the input space represents a separate and parallel standard
DET exploration of the uncertain domain.
%
The HDET methodology allows the user to explore the uncertain domain
employing the best approach for each variable kind.
%
The addition of a grid sampling strategy among the usable approaches allows the
user to perform a discrete parametric study under aleatory and epistemic
uncertainties.

Regarding the input requirements, the HDET sampler is a ``sub-type'' of the\\
\xmlNode{DynamicEventTree} sampler.
%
For this reason, its specifications must be defined within a
\xmlNode{DynamicEventTree} block.
%
\attrsIntro

\begin{itemize}
  \itemsep0em
  \item \nameDescription
  \item \xmlAttr{print\_end\_XML}, \xmlDesc{optional string/boolean attribute},
    controls the dumping of a ``summary'' of the DET performed into an external
    XML.
    %
    \default{False}.
  \item \xmlAttr{maxSimulationTime}, \xmlDesc{optional float attribute}, this
    attribute controls the maximum ``mission'' time of the simulation
    underneath.
    %
    \default{None}.
\end{itemize}

\variableIntro{DynamicEventTree}

\begin{itemize}
  \item \variableDescription
  \variableChildrenIntro
  \begin{itemize}
    \item \distributionDescription
    \item \gridDescription
  \end{itemize}
\end{itemize}

In order to activate the \textbf{Hybrid Dynamic Event Tree}  sampler, the main 
\xmlNode{DynamicEventTree} block needs to contain, at least, an additional
sub-node called \xmlNode{HybridSamplerSettings}.
%
As already mentioned, the user can combine the Monte-Carlo, Stratified, and Grid
approaches in order to create a ``pre-sampling'' $N$-dimensional grid, from
whose nodes a standard DET method is employed.
%
For this reason, the user can specify a maximum of three
\xmlNode{HybridSamplerSettings} sub-nodes (i.e. one for each of the available
once-through samplers).
%
This sub-node needs to contain the following attribute:
\begin{itemize}
  \item \xmlAttr{type}, \xmlDesc{required string attribute}, type of
    pre-sampling strategy to be used.
    %
    Available options are \xmlString{MonteCarlo}, \xmlString{Grid}, and
    \xmlString{Stratified}.
 \end{itemize}

Independent of the type of ``pre-sampler'' that has been specified, the 
\xmlNode{HybridSamplerSettings} must contain the variables need to be sampled.
%
As already mentioned, these variables are specified within consecutive
\xmlNode{variable} XML blocks:

\begin{itemize}
  \item \variableDescription
    \variableChildIntro
    \begin{itemize}
      \item \distributionDescription
    \end{itemize}
 \end{itemize}

If a pre-sampling strategy \xmlAttr{type} is either \xmlString{Grid} or 
\xmlString{Stratified}, within the \xmlNode{variable} blocks, the user needs to 
specify the sub-node \xmlNode{grid}.
%
As with the standard DET, the content of this XML node depends on the definition
of the associated attributes:
\begin{itemize}
\itemsep0em
\item \xmlAttr{type}, \xmlDesc{required string attribute}, user-defined
  discretization metric type:
  \begin{itemize}
    \item \xmlString{CDF}, the grid is going to be specified based on the 
      cumulative distribution function probability thresholds
    \item \xmlString{value}, the grid is going to be provided using variable
      values.
  \end{itemize}
  \item \xmlAttr{construction}, \xmlDesc{required string attribute}, how the 
    grid needs to be constructed, independent of its type (i.e. \xmlString{CDF} 
    or \xmlString{value}).
\end{itemize}
\constructionGridDescription

Example:
\begin{lstlisting}[style=XML]
<Samplers>
  ...
  <DynamicEventTree name='HybridDETname' print_end_XML="True">
    <HybridSamplerSettings type='MonteCarlo' limit='2'>
      <variable name='var1' >
        <distribution>aDistributionNameDefinedInDistributionBlock1 </distribution> 
      </variable>
      <variable name='var2' >
        <distribution>aDistributionNameDefinedInDistributionBlock2 </distribution> 
        <grid type='CDF' construction='equal' steps='1' lowerBound='0.1'>0.1</grid>
      </variable>
    </HybridSamplerSettings>
    <HybridSamplerSettings type='Grid'>
      <!-- Point sampler way (directly sampling the variable) -->
      <variable name='var3' >
        <distribution>aDistributionNameDefinedInDistributionBlock3 </distribution> 
        <grid type='CDF' construction='equal' steps='1' lowerBound='0.1'>0.1</grid>
      </variable>
      <variable name='var4' >
        <distribution>aDistributionNameDefinedInDistributionBlock4 </distribution> 
        <grid type='CDF' construction='equal' steps='1' lowerBound='0.1'>0.1</grid>
      </variable>
    </HybridSamplerSettings>
    <HybridSamplerSettings type='Stratified'>
      <!-- Point sampler way (directly sampling the variable ) -->
      <variable name='var5' >
        <distribution>aDistributionNameDefinedInDistributionBlock5 </distribution> 
        <grid type='CDF' construction='equal' steps='1' lowerBound='0.1'>0.1</grid>
      </variable>
      <variable name='var6' >
        <distribution>aDistributionNameDefinedInDistributionBlock6 </distribution> 
        <grid type='CDF' construction='equal' steps='1' lowerBound='0.1'>0.1</grid>
      </variable>
    </HybridSamplerSettings>
    <!-- DYNAMIC EVENT TREE INPUT (it goes outside an inner block like HybridSamplerSettings) -->
      <Distribution name='dist7'>
        <distribution>aDistributionNameDefinedInDistributionBlock7 </distribution> 
        <grid type='CDF' construction='custom'>0.1 0.8</grid>
      </Distribution>
  </DynamicEventTree>
  ...
</Samplers>
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Adaptive Samplers %%%
%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Adaptive Samplers}
\label{subsec:AdaptSamplers}
The Adaptive Samplers' family provides the possibility to perform smart sampling
(also known as adaptive sampling) as an alternative to classical “once-through”
techniques.
%
The motivation is that system simulations are often computationally expensive,
time-consuming, and high dimensional with respect to the number of input
parameters.
%
Thus, exploring the space of all possible simulation outcomes is infeasible
using finite computing resources.
%
During simulation-based probabilistic risk analysis, it is important to discover
the relationship between a potentially large number of input parameters and the
output of a simulation using as few simulation trials as possible.

The description above characterizes a typical context for performing adaptive
sampling where a few observations are obtained from the simulation, a reduced
order model (ROM) is built to represent the simulation space, and new samples
are selected based on the model constructed.
%
The reduced order model (see section \ref{subsec:models_ROM}) is then updated
based on the simulation results of the sampled points.
%
In this way, an attempt is made to gain the most information possible with a
small number of carefully selected sample points, limiting the number of
expensive trials needed to understand features of the system space.
%

Currently, RAVEN provides support for two adaptive algorithms:

\begin{itemize}
  \item Adaptive Sampler for Limit Surface Search
  \item Adaptive Dynamic Event Tree
\end{itemize}

In the following paragraphs, the input requirements and a small explanation of
the different sampling methods are reported.

%%% Adaptive Samplers: Adaptive Sampling for Limit Surface search
\subsubsection{Adaptive Sampler}
\label{subsubsubsec:AdaptiveSampling}
The \textbf{Adaptive Sampler} approach is an advanced methodology that employs
a smart sampling around transition zones that determine a change in the status
of the system (limit surface).
%
To perform such sampling, RAVEN uses ROMs for predicting, in the input space,
the location(s) of these transitions, in order to accelerate the exploration of
the input space in proximity of the limit surface.
%

\specBlock{an}{Adaptive}
%
\attrIntro

\begin{itemize}
  \itemsep0em
  \item \nameDescription
\end{itemize}

\variableIntro{Adaptive}

\begin{itemize}
  \item \variableDescription
    \variableChildIntro
    \begin{itemize}
      \item \distributionDescription
    \end{itemize}
\end{itemize}

In addition to the \xmlNode{variable} nodes, the main XML node 
\xmlNode{Adaptive} needs to contain two supplementary sub-nodes:

\begin{itemize}
  \item \convergenceDescription

  % Assembler Objects
  \item \assemblerDescription

\end{itemize}

Example:
\begin{lstlisting}[style=XML,morekeywords={class,limit,subGridTol,weight,persistence}]
<Samplers>
  ...
  <Adaptive name='AdaptiveName'>
    <ROM class='Models' type='ROM'>ROMname</ROM>
    <Function class='Functions' type='External' >FunctionName</Function>
    <TargetEvaluation class='Datas' type='TimePointSet'>DataName</TargetEvaluation>
    <Convergence limit='3000'  forceIteration='False' weight='none' persistence='5'>
      1e-2
    </Convergence>
    <variable name='var1'>
      <distribution>aDistributionNameDefinedInDistributionBlock1 </distribution> 
    </variable>
    <variable name='var2'>
      <distribution>aDistributionNameDefinedInDistributionBlock2 </distribution> 
    </variable>
    <variable name='var3'>
      <distribution>aDistributionNameDefinedInDistributionBlock3 </distribution> 
    </variable>
  </Adaptive>
  ...
</Samplers>
\end{lstlisting}

Associated External Python Module:
\begin{lstlisting}[language=python]
def __residuumSign(self):
  if self.whatEverValue < self.OtherValue :
    return  1
  else:
    return -1
\end{lstlisting}

%%% Adaptive Samplers: Adaptive Sampling for Limit Surface search
\subsubsection{Adaptive Dynamic Event Tree}
\label{subsubsubsec:ADET}
The \textbf{Adaptive Dynamic Event Tree} approach is an advanced methodology 
employing a smart sampling around transition zones that determine a change in
the status of the system (limit surface), using the support of a Dynamic Event
Tree methodology.
%
The main idea of the application of the previously explained adaptive sampling
approach to the DET comes from the observation that the DET, when evaluated from
a limit surface perspective, is intrinsically adaptive.
%
For this reason, it appears natural to use the DET approach to perform a
goal-function oriented pre-sampling of the input space.

RAVEN uses ROMs for predicting, in the input space,
the location(s) of these transitions, in order to accelerate the exploration of
the input space in proximity of the limit surface.

\specBlock{an}{AdaptiveDynamicEventTree}
%
\attrIntro

\begin{itemize}
  \itemsep0em
  \item \nameDescription
  \item \xmlAttr{print\_end\_XML}, \xmlDesc{optional string/boolean attribute},
    this attribute controls the dumping of a ``summary'' of the DET performed in
    to an external XML.
    %
    \default{False}.
  \item \xmlAttr{maxSimulationTime}, \xmlDesc{optional float attribute}, this
    attribute controls the maximum ``mission'' time of the simulation
    underneath.
    %
    \default{None}.
  \item \xmlAttr{mode}, \xmlDesc{optional string attribute}, controls when the
    adaptive search needs to begin.
    %
    Two options are available:
    \begin{itemize}
       \item \xmlString{post}, if this option is activated, the sampler first
         performs a standard Dynamic Event Tree analysis. At end of it, it uses
         the outcomes to start the adaptive search in conjunction with the DET
         support.
       \item \xmlString{online}, if this option is activated, the adaptive
         search starts at the beginning, during the initial standard Dynamic
         Event Tree analysis.
         %
         Whenever a transition is detected, the 
         \textbf{Adaptive Dynamic Event Tree} starts its goal-oriented search
         using the DET as support;
    \end{itemize}
      \default{post}.
%  \item \textbf{noTransitionStrategy}, \textit{optional string attribute}, strategy if no transition detected. This attribute controls how to handle the case in which no transitions have been detected through the initial DET grid.  %Two options are available:
 %     \begin{itemize}
  %       \item \textit{noTransitionStrategy = mc}, if this option is activated, when the initial DET grid did not detect any transition, a MC point in space is requested;
   %      \item \textit{noTransitionStrategy = grid},  if this option is activated, the adaptive search starts at begin, during the initial standard Dynamic Event Tree. Whenever a transition is detected, the \textbf{Adaptive Dynamic Event Tree} starts it goal-oriented search using the DET as support;
  %    \end{itemize}
   %   \default{post}.
  \item \xmlAttr{updateGrid}, \xmlDesc{optional boolean attribute}, if true, 
    each adaptive request is going to update the meshing of the initial DET
    grid.
    %
    \default{True}.
\end{itemize}
\variableIntro{AdaptiveDynamicEventTree}
\begin{itemize}
\item \variableDescription
  \variableChildrenIntro
 \begin{itemize}
    \item \distributionDescription
    \item \gridDescription
  \end{itemize}
\end{itemize}

 In addition to the \xmlNode{variable} nodes, the main
\xmlNode{AdaptiveDynamicEventTree} node needs to contain two supplementary
sub-nodes:

\begin{itemize}
  \item \convergenceDescription
  % Assembler Objects
  \item \assemblerDescription
\end{itemize}


Example:
\begin{lstlisting}[style=XML]
<Samplers>
  ...
  <AdaptiveDynamicEventTree name = 'AdaptiveName'>
    <ROM class = 'Models' type = 'ROM'ROMname</ROM>
    <Function class = 'Functions' type = 'External'>FunctionName</Function>
    <TargetEvaluation class = 'Datas' type = 'TimePointSet'>DataName</TargetEvaluation>
    <Convergence limit = '3000' subGridTol= '0.001' forceIteration = 'False' weight = 'none' persistence = '5'>
      1e-2
    </Convergence>
    <variable name = 'var1'>
        <distribution>
         aDistributionNameDefinedInDistributionBlock1
        </distribution> 
        <grid type='CDF' construction='custom'>0.1 0.8</grid>
    </variable>
    <variable name = 'var2'>
        <distribution>
          aDistributionNameDefinedInDistributionBlock2
        </distribution> 
        <grid type='CDF' construction='custom'>0.1 0.8</grid>
    </variable>
    <variable name = 'var3'>
        <distribution>
          aDistributionNameDefinedInDistributionBlock3
        </distribution> 
        <grid type='CDF' construction='custom'>0.1 0.8</grid>
    </variable>
  </AdaptiveDynamicEventTree>
  ...
</Samplers>
\end{lstlisting}

Associated External Python Module:
\begin{lstlisting}[language=python]
def __residuumSign(self):
  if self.whatEverValue < self.OtherValue:
    return  1
  else:
    return -1
\end{lstlisting}