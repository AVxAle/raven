\section{Datas  \\ \vspace{2 mm} {\small }}
\label{sec:Datas}
As it could infer from the previous chapters,  in the RAVEN code different entities interact to each other in order to create, ideally, an infinite number of different calculation flows. These interactions are performed through a system that is ``understandable'' by each ``entity''. This system, neglecting the grammar imprecision,  is called ``Datas'' system. The ``Datas'' system is a container of Data objects of different type that can be constructed during the evolution of the particular calculation flow, can be used as input or output of particular Model (see Roles' meaning in section \ref{sec:models}), etc. 
Currently, RAVEN support 4 different data types, each with a particular conceptual meaning:
\begin{itemize}
\item \textbf{TimePoint}: The \textit{TimePoint} entity, as the name suggests, ``describes'' the state of the system in a certain point in time. In other words, it can be considered a mapping between a set of parameters in the input space and the resulting outcomes in the output space at a particular time;
\item \textbf{TimePointSet}: The \textit{TimePointSet} object is, obviously, a collection of single \textit{TimePoint(s)}. It can be considered a mapping between multiple sets of parameters in the input space and the resulting sets of outcomes in the output space at a particular point in time;
\item \textbf{History}:  The \textit{History} entity ``describes'' the temporal evolution of the state of the system within a certain input domain;
\item \textbf{Histories}:  The \textit{Histories} object is, obviously, a collection of single \textit{History(ies)}. t can be considered a mapping between multiple sets of parameters in the input space and the resulting sets of temporal evolutions in the output space.
\end{itemize}
As inferable  from the brief description reported above, each ``Data'' object represents a mapping between a set of parameters and the resulting outcomes.
The Data objects are defined within the main XML block called $<Datas>$:
\begin{lstlisting}[style=XML]
-----------------------------
<Simulation>
   ...
  <Datas> 
    <WhatEverData name='***'>  
     ... 
    </WhatEverData> 
  </Datas>
   ...
</Simulation>
-----------------------------
\end{lstlisting}

The specifications of each ``Data'' type must be defined within:
\begin{itemize}
   \item \textbf{TimePoint} $=>$ $<TimePoint>$
   \item \textbf{TimePointSet} $=>$ $<TimePointSet>$
   \item \textbf{History} $=>$ $<History>$
   \item \textbf{Histories} $=>$ $<Histories>$
\end{itemize}
Independently on the type of Data, the respective XML node needs (or not) to contain the attribute:
\vspace{-5mm}
\begin{itemize}
\itemsep0em
\item \textbf{name}, \textit{required string attribute}, user-defined name of this Data. N.B. As for the other objects, this is the name that can be used to refer to this specific entity from other input blocks (xml);
% Regarding the time attribute, we need to take a better decision... Now it is very confusing.
%\item \textbf{time}, \textit{optional float or string attribute}, time attribute. The user can here specify either the time (value) at which the outcomes need to be taken (History-like object, it represents the time from which the outcomes' evolution need to be tracked) or a string  that can be either ``end'', at the end of the hystory, or ``all'', consider     . \textit{Default = random seed};
\item \textbf{inputTs}, \textit{optional integer attribute}, This attribute can be used to specify at which ``time step'' the input space needs to be retrieved. NB. If the user wants to take those conditions from the end of the simulation, it can directly input ``-1''. \textit{Default = 0};
\item \textbf{operator}, \textit{optional string attribute}, The operator attribute is aimed to perform simple operations on the data to be stored. The 3 options currently available are \textit{operator = max}, \textit{operator = min}, \textit{operator = average}, with obvious meaning. \textit{Default = None};
\item \textbf{hierarchical}, \textit{optional boolean attribute}, If True this data is going to be constructed, if possible, in an hierarchical fashion. \textit{Default = False};
\end{itemize}
\vspace{-5mm}
In each XML node (e.g. $<TimePoint>$ or $<Histories>$), the user needs to specify the following sub nodes:
\begin{itemize}
 \item $<Inputs>$\textbf{\textit{, comma separated string, required field.}}.  List of input parameters this data is connected to. NB. In case the ``Data'' type is either \textit{TimePoint} or  \textit{History}, this XML node must contain the attribute \textbf{history}, where the name of the associated history needs to be placed;
 \item $<Outputs>$\textbf{\textit{, comma separated string, required field.}}.  List of output parameters this data is connected to;
\end{itemize}

\begin{lstlisting}[style=XML]
----------------------------------------------------------
<Datas> 
   <TimePoint name='***' inputTs='-1' operator='max' hierarchical='False'>  
      <Input history='a_history_name'>***,***,***</Input>
      <Output>***,***</Output>
   </TimePoint> 
   <TimePointSet name='***'>  
      <Input>***,***,***</Input>
      <Output>***,***</Output>
    </TimePointSet> 
    <History name='***'>  
      <Input history='a_history_name'>***,***,***</Input>
      <Output>***,***</Output>
    </History> 
    <Histories name='***'>  
      <Input>***,***,***</Input>
      <Output>***,***</Output>
    </Histories> 
</Datas>
----------------------------------------------------------
\end{lstlisting}

\section{Databases}
\label{sec:Databases}
The RAVEN framework provides the capability to store and retrieve data to/from an external database. Currently RAVEN has support for only a database type called \textbf{HDF5}. This database, depending on the data format is receiving, will organize itself in a ``parallel'' or ``hierarchical'' fashion. The user can create as many database objects as needed.
The DataBase objects are defined  within the main XML block called $<DataBases>$:
\begin{lstlisting}[style=XML]
-----------------------------
<Simulation>
   ...
  <DataBases>
        ...
        <HDF5 name="***"/>
        <HDF5 name="***"/>
        ...
  </DataBases>
   ...
</Simulation>
-----------------------------
\end{lstlisting}
The specifications of each DataBase of type HDF5 needs to be defined within the XML block $<HDF5>$, that  needs (or not) to contain  the attributes:
\vspace{-5mm}
\begin{itemize}
\itemsep0em
\item \textbf{name}, \textit{required string attribute}, user-defined name of this Data. N.B. As for the other objects, this is the name that can be used to refer to this specific entity from other input blocks (xml);
\item \textbf{directory}, \textit{optional string attribute}, this attribute can be used to specify a particular directory path where to create the database, if no \textit{filename} is specified, or from where open an already existing one, if \textit{filename} is provided. \textit{Default = raven/framework/DataBaseStorage};
\item \textbf{filename}, \textit{optional string attribute}, this attribute can be used to specified the filename of an HDF5 that already exists in the \textit{directory}. This is the only way to let RAVEN know that an HDF5 should be opened and not overwritten. NB. When this attribute is not specified, the newer database filename is going to be named \textit{name}.h5. \textit{Default = None};
\item \textbf{compression}, \textit{optional string attribute}, compression algorithm to be used. Available are:
   \begin{itemize}
      \item \textit{compression = gzip}, best where portability is required. Good compression, moderate speed;
      \item \textit{compression = lzf}, Low to moderate compression, very fast.
   \end{itemize}
  \textit{Default = no compression};
\end{itemize}

\begin{lstlisting}[style=XML]
----------------------------------------------------------
<DataBases> 
   <HDF5 name="***" directory=''path_to_a_dir'' compression=''lzf''/>
   <HDF5 name="***" filename=''existing_hdf5.h5''/>
</DataBases>
----------------------------------------------------------
\end{lstlisting}

