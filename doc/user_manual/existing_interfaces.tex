\section{Existing Interfaces}
\label{sec:existingInterface}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%% Gneric  INTERFACE  %%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Generic Interface}
The GenericCode interface is meant to handle a wide variety of generic codes 
that take take straightforward input files and produce output CSV files.  There are
some limitations for this interface.  
If a code: \vspace{-20pt}
\begin{itemize}
\item accepts a keyword-based input file with no cross-dependent inputs,
\item has no more than one filetype extension per command line flag,
\item and returns a CSV with the input parameters and output parameters,
\end{itemize}\vspace{-20pt}
the GenericCode interface should cover the code for RAVEN.

If a code contains cross-dependent data, the generic interface is not able to
edit the correct values.  For example, if a geometry-building script specifies
inner\_radius, outer\_radius, and thickness, the generic interface cannot 
calculate the thickness given the outer and inner radius, or vice versa.

 An example of the code interface is shown here.  The input parameters are read 
 from the input files \texttt{gen.one} and \texttt{gen.two} respectively.
 The code is run using \texttt{python}, so that is part of the \xmlNode{prepend} node.
 The command line entry to normally run the code is
\begin{lstlisting}[language=bash]
python poly_inp.py -i gen.one -a gen.two -o myOut
\end{lstlisting}
and produces the output \texttt{myOut.csv}.

Example:
\begin{lstlisting}[style=XML]
    <Code name="poly" subType="GenericCode">
      <executable>GenericInterface/poly_inp.py</executable>
      <inputExtentions>.one,.two</inputExtentions>
      <clargs type='prepend' arg='python'/>
      <clargs type='input'   arg='-i' extension='.one'/>
      <clargs type='input'   arg='-a' extension='.two'/>
      <clargs type='output'  arg='-o'/>
      <prepend>python</prepend>
    </Code>
\end{lstlisting}

If a code doesn't accept necessary Raven-editable auxiliary input files 
or output filenames through the command line, the GenericCode interface
can also edit the input files and insert the filenames there.  For example,
in the previous example, say instead of \texttt{-a gen.two} and \texttt{-o myOut}
in the command line, \texttt{gen.one} has the following lines:
\begin{lstlisting}[language=python]
...
auxfile = gen.two
case = myOut
...
\end{lstlisting}
Then, our example XML for the code would be

Example:
\begin{lstlisting}[style=XML]
    <Code name="poly" subType="GenericCode">
      <executable>GenericInterface/poly_inp.py</executable>
      <inputExtentions>.one,.two</inputExtentions>
      <clargs   type='prepend' arg='python'/>
      <clargs   type='input'   arg='-i'  extension='.one'/>
      <fileargs type='input'   arg='two' extension='.two'/>
      <fileargs type='output'  arg='out'/>
      <prepend>python</prepend>
    </Code>
\end{lstlisting}
and the corresponding template input file lines would be changed to read
\begin{lstlisting}[language=python]
...
auxfile = $RAVEN-two$
case = $RAVEN-out$
...
\end{lstlisting}

In addition, the ``wild-cards'' above can contain two special and optional symbols:
\begin{itemize}
  \item  \texttt{:}, that defines an eventual default value;
  \item  \texttt{|}, that defines the format of the value. The  Generic Interface currently supports the following formatting options (* in the examples means blank space):
    \begin{itemize}
       \item \textbf{plain integer}, in this case  the value that is going to be replaced by the Generic Interface, will be left-justified with a string length equal to the integer value specified here (e.g. ``\texttt{|}6'', the value is left-justified with a string length of 6);
      \item \textbf{d}, signed integer decimal, the value is going to be formatted as an integer (e.g.  if the value is 9 and the format ``\texttt{|}10d'', the replaced value will be formatted as follows: ``*********9'');
      \item \textbf{e}, floating point exponential format (lowercase), the value is going to be formatted as a float in scientific notation (e.g. if the value is 9.1234 and the format ``\texttt{|}10.3e'', the replaced value will be formatted as follows: ``*9.123e+00'' );
      \item \textbf{E}, floating point exponential format (uppercase), the value is going to be formatted as a float in scientific notation (e.g. if the value is 9.1234 and the format ``\texttt{|}10.3E'', the replaced value will be formatted as follows: ``*9.123E+00'' );
      \item \textbf{f or F}, floating point decimal format, the value is going to be formatted as a float in decimal notation (e.g. if the value is 9.1234 and the format ``\texttt{|}10.3f'', the replaced value will be formatted as follows: ``*****9.123'' );
      \item \textbf{g}, floating point format. Uses lowercase exponential format if exponent is less than -4 or not less than precision, decimal format otherwise (e.g. if the value is 9.1234 and the format ``\texttt{|}10.3g'', the replaced value will be formatted as follows: ``******9.12'' );
      \item \textbf{G}, floating point format. Uses uppercase exponential format if exponent is less than -4 or not less than precision, decimal format otherwise (e.g. if the value is 0.000009 and the format ``\texttt{|}10.3G'', the replaced value will be formatted as follows: ``*****9E-06'' ).
    \end{itemize}|
\end{itemize}
For example:
\begin{lstlisting}[language=python]
...
auxfile = $RAVEN-two:3$
case = $RAVEN-out:5|10$
...
\end{lstlisting}
Where, 
\begin{itemize}
  \item  \texttt{:}, in case the variable ``two'' is not defined in the RAVEN XML input file, the Parser, will replace it with the value ``3''.;
  \item  \texttt{|}, the value that is going to be replaced by the Generic Interface, will be left- justified with a string length of ``10'';
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%% RELAP5  INTERFACE  %%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{RELAP5 Interface}

\subsubsection{Files}
In the \xmlNode{Files} section, as specified before, all of the files needed for
the code to run should be specified.
%
In the case of RELAP5, the files typically needed are:
\begin{itemize}
  \item RELAP5 Input file
  \item Table file or files that RELAP needs to run
  \item The Relap5 executable
\end{itemize}
Example:
\begin{lstlisting}[style=XML]
<Files>X10.i,tpfh2o,r5executable.x</Files>
\end{lstlisting}

It is a good practice to put inside the working directory all of these files and
also:
\begin{itemize}
  \item the RAVEN input file
  \item the license for the executable of RELAP5
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Sequence}
In the \xmlNode{Sequence} section, the names of the steps declared in the
\xmlNode{Steps} block should be specified.
%
As an example, if we called the first multirun ``Grid\_Sampler'' and the second
multirun ``MC\_Sampler'' in the sequence section we should see this:
\begin{lstlisting}[style=XML]
<Sequence>Grid_Sampler,MC_Sampler</Sequence>
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{batchSize and mode}
For the \xmlNode{batchSize} and \xmlNode{mode} sections please refer to the
\xmlNode{RunInfo} block in the previous chapters.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{RunInfo}
After all of these blocks are filled out, a standard example RunInfo block may
look like the example below:
\begin{lstlisting}[style=XML]
<RunInfo>
  <WorkingDir>~/working_dir</WorkingDir>
  <Files>inputfilerelap.i,tpfh2o,executablerelap5.x</Files>
  <Sequence>Grid_Sampler,MC_Sampler</Sequence>
  <batchSize>1</batchSize>
  <mode>mpi</mode>
  <expectedTime>1:00:00</expectedTime>
  <ParallelProcNumb>1</ParallelProcNumb>
</RunInfo>
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Models}
For the \xmlNode{Models} block here is a standard example of how it would look
when using RELAP5 as the external model:
\begin{lstlisting}[style=XML]
<Models>
  <Code name='MyRELAP' subType='Relap5'>
    <executable>~/path_to_the_executable</executable>
  </Code>
</Models>
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Distributions}
The \xmlNode{Distribution} block defines the distributions that are going
to be used for the sampling of the variables defined in the \xmlNode{Samplers}
block.
%
For all the possibile distributions and all their possible inputs please see the
chapter about Distributions (see~\ref{sec:distributions}).
%
Here we give a general example of three different distributions:
\begin{lstlisting}[style=XML,morekeywords={name,debug}]
<Distributions verbosity='debug'>
  <Triangular name='BPfailtime'>
    <apex>5.0</apex>
    <min>4.0</min>
    <max>6.0</max>
  </Triangular>
  <LogNormal name='BPrepairtime'>
    <mean>0.75</mean>
    <sigma>0.25</sigma>
  </LogNormal>
  <Uniform name='ScalFactPower'>
    <lowerBound>1.0</lowerBound>
    <upperBound>1.2</upperBound>
  </Uniform>
 </Distributions>
\end{lstlisting}

It is good practice to name the distribution something similar to what kind of
variable is going to be sampled, since there might be many variables with the
same kind of distributions but different input parameters.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Samplers}
In the \xmlNode{Samplers} block we want to define the variables that are going
to be sampled.
%
\textbf{Example}:
We want to do the sampling of 3 variables:
\begin{itemize}
  \item Battery Fail Time
  \item Battery Repair Time
  \item Scaling Factor Power Rate
\end{itemize}

We are going to sample these 3 variables using two different sampling methods:
grid and MonteCarlo.

In RELAP5, the sampler reads the variable as, given the name, the first number
is the card number and the second number is the word number.
%
In this example we are sampling:
\begin{itemize}
  \item For card 0000588 (trip) the word 6 (battery failure time)
  \item For card 0000575 (trip) the word 6 (battery repari time)
  \item For card 20210000 (reactor power) the word 4 (reactor scaling factor)
\end{itemize}

We proceed to do so for both the Grid sampling and the MonteCarlo sampling.

\begin{lstlisting}[style=XML,morekeywords={name,type,construction,lowerBound,steps,limit,initial_seed}]
<Samplers verbosity='debug'>
  <Grid name='Grid_Sampler' >
    <variable name='0000588:6'>
      <distribution>BPfailtime</distribution>
      <grid type='value' construction='equal' lowerBound='0.0' steps='10'>2880</grid>
    </variable>
    <variable name='0000575:6'>
      <distribution>BPrepairtime</distribution>
      <grid type='value' construction='equal' lowerBound='0.0' steps='10'>2880</grid>
    </variable>
    <variable name='20210000:4'>
      <distribution>ScalFactPower</distribution>
      <grid type='value' construction='equal' lowerBound='1.0' steps='10'>0.02</grid>
    </variable>
  </Grid>
  <MonteCarlo name='MC_Sampler' limit='1000'>
    <variable name='0000588:6'>
      <distribution>BPfailtime</distribution>
    </variable>
    <variable name='0000575:6'>
      <distribution>BPrepairtime</distribution>
    </variable>
    <variable name='20210000:4'>
      <distribution>ScalFactPower</distribution>
    </variable>
  </MonteCarlo>
</Samplers>
\end{lstlisting}

It can be seen that each variable is connected with a proper distribution
defined in the \\\xmlNode{Distributions} block (from the previous example).
%
The following demonstrates how the input for the first variable is read.

We are sampling a a variable situated in word 6 of the card 0000588 using a Grid
sampling method.
%
The distribution that this variable is following is a Triangular distribution
(see section above).
%
We are sampling this variable beginning from 0.0 in 10 \textit{equal} steps of
2880.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Steps}
For a RELAP interface, the \xmlNode{MultiRun} step type will most likely be
used.
%
First, the step needs to be named: this name will be one of the names used in
the \xmlNode{Sequence} block.
%
In our example, \texttt{Grid\_Sampler} and \texttt{MC\_Sampler}.
%
\begin{lstlisting}[style=XML,morekeywords={name,debug,re-seeding}]
     <MultiRun name='Grid_Sampler' verbosity='debug'>
\end{lstlisting}

With this step, we need to import all the files needed for the simulation:
\begin{itemize}
  \item RELAP input file
  \item element tables -- tpfh2o
\end{itemize}
\begin{lstlisting}[style=XML,morekeywords={name,class,type}]
    <Input   class='Files' type=''>inputrelap.i</Input>
    <Input   class='Files' type=''>tpfh2o</Input>
\end{lstlisting}
We then need to define which model will be used:
\begin{lstlisting}[style=XML]
    <Model  class='Models' type='Code'>MyRELAP</Model>
\end{lstlisting}
We then need to specify which Sampler is used, and this can be done as follows:
\begin{lstlisting}[style=XML]
    <Sampler class='Samplers' type='Grid'>Grid_Sampler</Sampler>
\end{lstlisting}
And lastly, we need to specify what kind of output the user wants.
%
For example the user might want to make a database (in RAVEN the database
created is an HDF5 file).
%
Here is a classical example:
\begin{lstlisting}[style=XML,morekeywords={class,type}]
    <Output  class='Databases' type='HDF5'>MC_out</Output>
\end{lstlisting}
Following is the example of two MultiRun steps which use different sampling
methods (grid and Monte Carlo), and creating two different databases for each
one:
\begin{lstlisting}[style=XML]
<Steps verbosity='debug'>
  <MultiRun name='Grid_Sampler' verbosity='debug'>
    <Input   class='Files'     type=''    >X10.i</Input>
    <Input   class='Files'     type=''    >r5executable.x</Input>
    <Input   class='Files'     type=''    >tpfh2o</Input>
    <Model   class='Models'    type='Code'>MyRELAP</Model>
    <Sampler class='Samplers'  type='Grid'>Grid_Sampler</Sampler>
    <Output  class='Databases' type='HDF5'>Grid_out</Output>
  </MultiRun>
  <MultiRun name='MC_Sampler' verbosity='debug' re-seeding='210491'>
    <Input   class='Files'     type=''          >X10.i</Input>
    <Input   class='Files'     type=''          >r5executable.x</Input>
    <Input   class='Files'     type=''          >tpfh2o</Input>
    <Model   class='Models'    type='Code'      >MyRELAP</Model>
    <Sampler class='Samplers'  type='MonteCarlo'>MC_Sampler</Sampler>
    <Output  class='Databases' type='HDF5'      >MC_out</Output>
  </MultiRun>
</Steps>
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Databases}
As shown in the \xmlNode{Steps} block, the code is creating two database objects
called \texttt{Grid\_out} and \texttt{MC\_out}.
%
So the user needs to input the following:
\begin{lstlisting}[style=XML]
<Databases>
  <HDF5 name="Grid_out"/>
  <HDF5 name="MC_out"/>
</Databases>
\end{lstlisting}
As listed before, this will create two databases.
%
The files will have names corresponding to their \xmlAttr{name} appended with
the .h5 extension (i.e. \texttt{Grid\_out.h5} and \texttt{MC\_out.h5}).
%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%% RELAP7 INTERFACE  %%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{RELAP7 Interface}
\subsubsection{Files}
In the \xmlNode{Files} section, as specified before, all of the files needed for
the code to run should be specified.
%
In the case of RELAP7, the files typically needed are the following:
\begin{itemize}
  \item RELAP7 Input file
  \item Control Logic file
\end{itemize}
Example:
\begin{lstlisting}[style=XML]
<Files>nat_circ,control_logic.py</Files>
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Models}
For the \xmlNode{Models} block RELAP7 uses the RAVEN executable.
%
Here is a standard example of what can be used to use RELAP7 as the model:
\begin{lstlisting}[style=XML]
<Models>
    <Code name='MyRAVEN' subType='RAVEN'><executable>~path/to/RAVEN-opt</executable></Code>
</Models>
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Distributions}
The \xmlNode{Distributions} block, when using RELAP7, has to also be specified
through the control logic.
%\maljdan{Reword possibly, I am not sure what you are trying to say.}
%The \xmlNode{Distributions} block, when using RELAP7, has to be specified also
%through the control logic.
%
Given the names of the distributions and their parameters, a python file should
be used for the control logic.
%
For example, the sampling of a normal distribution for the primary pressure in
RELAP7 is required.
%
\begin{lstlisting}[style=XML]
<Distributions>
 <Normal name="Prim_Pres">
 <mean>1000000</mean>
 <sigma>100<sigma/>
 </Normal>
</Distributions>
\end{lstlisting}

The python file associated to it should look like this:
%\lstset{margin=1.5cm}
\begin{lstlisting}[language=Python]
def initial_function(monitored, controlled, auxiliary)
    print("monitored",monitored,"controlled",
    controlled,"auxiliary",auxiliary)

    controlled.pressure_in_pressurizer =
     distributions.Prim_Pres.getDistributionRandom()
    return
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Samplers}
In the \xmlNode{Samplers} block, which kind of sampling method used, the
variables not sampled inside the control logic, and the distributions for the
chosen sampling method will be defined.
%
For the example, we are performing Monte Carlo sampling with 500 runs.
%
The global initial pressure wasn't specified in the control logic so it is
sampled in this block.
%
In addition, the initial pressure is specified to follow the same distribution
as the primary pressure.
%
\begin{lstlisting}[style=XML]
<Samplers>
 <MonteCarlo name="MC_samp" limit="500">
  <variable name="GlobalParams|global_init_P">
   <distribution>Prim_Pres</distribution>
  </variable>
 </MonteCarlo>
</Samplers>
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%% MooseBasedApp INTERFACE  %%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{MooseBasedApp Interface}
\subsubsection{Files}
In the \xmlNode{Files} section, as specified before, all of the files needed for
the code to run should be specified.
%
In the case of any MooseBasedApp, the files typically needed are the following:
\begin{itemize}
  \item MooseBasedApp YAML input file
  \item Restart Files (if the calculation is instantiated from a restart point)
\end{itemize}
Example:
\begin{lstlisting}[style=XML]
<Files>mooseBasedApp.i,0020_mesh.cpr,0020.xdr.0000,0020.rd-0</Files>
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Models}
In the \xmlNode{Models} block particular MooseBasedApp executable needs to be specified.
%
Here is a standard example of what can be used to use with a typical MooseBasedApp (Bison) as the model:
\begin{lstlisting}[style=XML]
<Models>
    <Code name='MyMooseBasedApp' subType='MooseBasedApp'><executable>~path/to/Bison-opt</executable></Code>
</Models>
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Distributions}
The \xmlNode{Distribution} block defines the distributions that are going
to be used for the sampling of the variables defined in the \xmlNode{Samplers}
block.
%
For all the possible distributions and all their possible inputs please see the
chapter about Distributions (see~\ref{sec:distributions}).
%
Here we give a general example of three different distributions:
\begin{lstlisting}[style=XML,morekeywords={name,debug}]
<Distributions>
    <Normal name='ThermalConductivity1'>
        <mean>1</mean>
        <sigma>0.001</sigma>
        <lowerBound>0.5</lowerBound>
        <upperBound>1.5</upperBound>
    </Normal>
    <Normal name='SpecificHeat'>
        <mean>1</mean>
        <sigma>0.4</sigma>
        <lowerBound>0.5</lowerBound>
        <upperBound>1.5</upperBound>
    </Normal>
    <Triangular name='ThermalConductivity2'>
        <apex>1</apex>
        <min>0.1</min>
        <max>4</max>
    </Triangular>
</Distributions>
\end{lstlisting}

It is good practice to name the distribution something similar to what kind of
variable is going to be sampled, since there might be many variables with the
same kind of distributions but different input parameters.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Samplers}
In the \xmlNode{Samplers} block we want to define the variables that are going
to be sampled.
%
\textbf{Example}:
We want to do the sampling of 3 variables:
\begin{itemize}
  \item Thermal Conductivity of the Fuel;
  \item Specific Heat Transfer Ratio of the Cladding;
  \item Thermal Conductivity of the Cladding.
\end{itemize}

We are going to sample these 3 variables using two different sampling methods:
Grid and Monte-Carlo.

In order to perturb any MooseBasedApp, the user needs to specify the variables to be
sampled indicating the path to the value separated with the symbol ``$|$''. For example,
if the variable that we want to perturb is specified in the input as follows:
\begin{lstlisting}[style=XML]
[Materials]
  ...
  [./heatStructure]
     ...
     thermal_conductivity = 1.0
     ...
  [../]
  ...
[]
\end{lstlisting}
the variable name in the Sampler input block needs to be named as follows:
\begin{lstlisting}[style=XML]
...
<Samplers>
  <aSampler name='aUserDefinedName' >
    <variable name='Materials|heatStructure|thermal_conductivity'>
      ...
    </variable>
  </aSampler>
</Samplers>
...
\end{lstlisting}
%
In this example, we proceed to do so for both the Grid sampling and the Monte-Carlo sampling.

\begin{lstlisting}[style=XML,morekeywords={name,type,construction,lowerBound,steps,limit,initial_seed}]
<Samplers verbosity='debug'>
    <Grid name='myGrid'>
      <variable name='Materials|heatStructure1|thermal_conductivity' >
        <distribution>ThermalConductivity1</distribution>
        <grid         type='value' construction='custom' >0.6 0.7 0.8</grid>
      </variable>
      <variable name='Materials|heatStructure1|specific_heat' >
        <distribution >SpecificHeat</distribution>
        <grid         type='CDF'    construction='custom'>0.5 1.0 0.0</grid>
      </variable>
      <variable name='Materials|heatStructure2|thermal_conductivity'>
        <distribution  >ThermalConductivity2</distribution>
        <grid type='value' upperBound='4' construction='equal' steps='1'>0.5</grid>
      </variable>
    </Grid>
  <MonteCarlo name='MC_Sampler' limit='1000'>
      <variable name='Materials|heatStructure1|thermal_conductivity' >
        <distribution>ThermalConductivity1</distribution>
      </variable>
      <variable name='Materials|heatStructure1|specific_heat' >
        <distribution >SpecificHeat</distribution>
      </variable>
      <variable name='Materials|heatStructure2|thermal_conductivity'>
        <distribution  >ThermalConductivity2</distribution>
      </variable>
  </MonteCarlo>
</Samplers>
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Steps}
For a MooseBasedApp, the \xmlNode{MultiRun} step type will most likely be
used, as first step.
%
First, the step needs to be named: this name will be one of the names used in
the \xmlNode{Sequence} block.
%
In our example, \texttt{Grid\_Sampler} and \texttt{MC\_Sampler}.
%
\begin{lstlisting}[style=XML,morekeywords={name,debug,re-seeding}]
     <MultiRun name='Grid_Sampler' >
\end{lstlisting}

With this step, we need to import all the files needed for the simulation:
\begin{itemize}
  \item MooseBasedApp YAML input file;
  \item eventual restart files (optional);
  \item other auxiliary files (e.g., powerHistory tables, etc.). 
\end{itemize}
\begin{lstlisting}[style=XML,morekeywords={name,class,type}]
    <Input   class='Files' type=''>mooseBasedApp.i</Input>
    <Input   class='Files' type=''>0020_mesh.cpr</Input>
    <Input   class='Files' type=''>0020.xdr.0000</Input>
    <Input   class='Files' type=''>0020.rd-0</Input>
\end{lstlisting}
We then need to define which model will be used:
\begin{lstlisting}[style=XML]
    <Model  class='Models' type='Code'>MyMooseBasedApp</Model>
\end{lstlisting}
We then need to specify which Sampler is used, and this can be done as follows:
\begin{lstlisting}[style=XML]
    <Sampler class='Samplers' type='Grid'>Grid_Sampler</Sampler>
\end{lstlisting}
And lastly, we need to specify what kind of output the user wants.
%
For example the user might want to make a database (in RAVEN the database
created is an HDF5 file) and a DataObject of type TimePointSet, to use in sub-sequential
post-processing.
%
Here is a classical example:
\begin{lstlisting}[style=XML,morekeywords={class,type}]
    <Output  class='Databases' type='HDF5'>MC_out</Output>
    <Output  class='DataObjects' type='TimePointSet'>MCOutData</Output>
\end{lstlisting}

Following is the example of two MultiRun steps which use different sampling
methods (grid and Monte Carlo), and creating two different databases for each
one:
\begin{lstlisting}[style=XML]
<Steps verbosity='debug'>
  <MultiRun name='Grid_Sampler' verbosity='debug'>
    <Input  class='Files' type=''>mooseBasedApp.i</Input>
    <Input  class='Files' type=''>0020_mesh.cpr</Input>
    <Input  class='Files' type='' >0020.xdr.0000</Input>
    <Input  class='Files' type=''>0020.rd-0</Input>
    <Model  class='Models'    type='Code'>MyMooseBasedApp</Model>
    <Sampler class='Samplers'  type='Grid'>Grid_Sampler</Sampler>
    <Output  class='Databases' type='HDF5'>Grid_out</Output>
    <Output  class='DataObjects' type='TimePointSet'>gridOutData</Output>
  </MultiRun>
  <MultiRun name='MC_Sampler' verbosity='debug' re-seeding='210491'>
    <Input  class='Files' type=''>mooseBasedApp.i</Input>
    <Input  class='Files' type=''>0020_mesh.cpr</Input>
    <Input  class='Files' type='' >0020.xdr.0000</Input>
    <Input  class='Files' type=''>0020.rd-0</Input>
    <Model  class='Models'    type='Code'>MyMooseBasedApp</Model>
    <Sampler class='Samplers'  type='MonteCarlo' >MC_Sampler</Sampler>
    <Output  class='Databases' type='HDF5' >MC_out</Output>
    <Output  class='DataObjects' type='TimePointSet'>MCOutData</Output>
  </MultiRun>
</Steps>
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Databases}
As shown in the \xmlNode{Steps} block, the code is creating two database objects
called \texttt{Grid\_out} and \texttt{MC\_out}.
%
So the user needs to input the following:
\begin{lstlisting}[style=XML]
<Databases>
  <HDF5 name="Grid_out"/>
  <HDF5 name="MC_out"/>
</Databases>
\end{lstlisting}
As listed before, this will create two databases.
%
The files will have names corresponding to their \xmlAttr{name} appended with
the .h5 extension (i.e. \texttt{Grid\_out.h5} and \texttt{MC\_out.h5}).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{DataObjects}
As shown in the \xmlNode{Steps} block, the code is creating two DataObjects of type TimePointSet
called \texttt{gridOutData} and \texttt{MCOutData}.
%
So the user needs to input the following:
\begin{lstlisting}[style=XML]
<DataObjects>
    <TimePointSet name='gridOutData'>
      <Input>
          Materials|heatStructure2|thermal_conductivity,
          Materials|heatStructure1|specific_heat,
          Materials|heatStructure2|thermal_conductivity
      </Input>
      <Output>aveTempLeft</Output>
    </TimePointSet>
    <TimePointSet name='MCOutData'>
      <Input>
          Materials|heatStructure2|thermal_conductivity,
          Materials|heatStructure1|specific_heat,
          Materials|heatStructure2|thermal_conductivity
      </Input>
      <Output>aveTempLeft</Output>
    </TimePointSet>
</DataObjects>
\end{lstlisting}
As listed before, this will create two DataObjects that can be used in sub-sequential post-processing.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{OutStreamManager}
As fully explained in section~\ref{sec:outstream}, if the user want to print out or plot the content of a \textbf{DataObjects},
he needs to create an \textbf{OutStream} in the \xmlNode{OutStreamManager} XML block.
\\As it shown in the example below, for MooseBasedApp (and any other Code interface that might use the symbol $|$ 
for the Sampler's variable syntax), in the Plot \xmlNode{x} and \xmlNode{y} specification, the user needs to
utilize curly brackets.
\begin{lstlisting}[style=XML]
<OutStreamManager>
  <Print name='gridOutDataDumpCSV'>
    <type>csv</type>
    <source>gridOutData</source>
  </Print>
   <Plot verbosity='debug' name='test' dim='2' overwrite='False'>
    <plotSettings>
       <plot>
        <type>line</type>
        <x>MCOutData|Input|{Materials|heatStructure2|thermal_conductivity}</x>
        <y>MCOutData|Output|aveTempLeft</y>
        <kwargs><color>blue</color></kwargs>
      </plot>
    </plotSettings>
    <actions><how>screen,png</how></actions>
  </Plot>
</OutStreamManager>
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{OpenModelica Interface}
OpenModelica (\url{http://www.openmodelica.org}) is an open souce implementation of the Modelica simulation language.  Modelica is "a non-proprietary, 
object-oriented, equation based language to conveniently model complex physical systems containing, e.g., mechanical, electrical, electronic, hydraulic, 
thermal, control, electric power or process-oriented subcomponents."\footnote{\url{http://www.modelica.org}}.  Modelica models are specified in text files 
with a file extension of .mo.  A standard Modelica example called BouncingBall which simulates the trajectory of an object falling in one dimension from a 
height is shown as an example:
\begin{lstlisting}
model BouncingBall
  parameter Real e=0.7 "coefficient of restitution";
  parameter Real g=9.81 "gravity acceleration";
  Real h(start=1) "height of ball";
  Real v "velocity of ball";
  Boolean flying(start=true) "true, if ball is flying";
  Boolean impact;
  Real v_new;
  Integer foo;

equation
  impact = h <= 0.0;
  foo = if impact then 1 else 2;
  der(v) = if flying then -g else 0;
  der(h) = v;

  when {h <= 0.0 and v <= 0.0,impact} then
    v_new = if edge(impact) then -e*pre(v) else 0;
    flying = v_new > 0;
    reinit(v, v_new);
  end when;

end BouncingBall;
\end{lstlisting}

\subsubsection{Files}
An OpenModelica installation specific to the operating system is used to create a stand-alone executable program that performs the model calculations.  
A separate XML file containing model parameters and initial conditions is also generated as part of the build process.  The RAVEN OpenModelica interface 
modifies input parameters by changing copies of this file.  Both the executable and XML parameter file names must be provided to RAVEN.  In the case of 
the BouncingBall model previously mentioned on the Windows operating system, the \textless Files\textgreater  specification would look like:
\begin{lstlisting}[style=XML]
<Simulation>
  <RunInfo>
      ...
    <Files>BouncingBall_init.xml,BouncingBall.exe</Files>
      ...
  </RunInfo>
    ...
</Simulation>
\end{lstlisting}
\subsubsection{Models}
OpenModelica models may provide simulation output in a number of formats.  The particular format used is specified during the model generation
process.  RAVEN works best with Comma-Separated Value (CSV) files, which is one of the possible output format options.  Models are generated 
using the OpenModelica Shell (OMS) command-line interface, which is part of the OpenModelica installation.  To generate an executable that provides 
CSV-formatted output, use OMSl commands as follows:
\lstset{
    frame=single,
    breaklines=true,
    postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}
 \begin{enumerate}
\item Change to the directory containing the .mo file to generate an executable for:
\begin{lstlisting}
>> cd("C:/MinGW/msys/1.0/home/bobk/projects/raven/framework/CodeInterfaces/OpenModelica")
"C:/MinGW/msys/1.0/home/bobk/projects/raven/framework/CodeInterfaces/OpenModelica"
\end{lstlisting}
\item Load the model file into memory:
\begin{lstlisting}
>> loadFile("BouncingBall.mo")
true
\end{lstlisting}
\item Create the model executable, specifying CSV output format:
\begin{lstlisting}
>> buildModel(BouncingBall, outputFormat="csv")
{"C:/MinGW/msys/1.0/home/bobk/projects/raven/framework/CodeInterfaces/OpenModelica/BouncingBall","BouncingBall_init.xml"}
Warning: The initial conditions are not fully specified. Use +d=initialization for more information.
\end{lstlisting}
At this point the model executable and XML initialization file should have been created in the same directory as the original model file.
\end{enumerate}
The model executable is specified to RAVEN using the \textless Models\textgreater  section of the input file as follows:
\begin{lstlisting}[style=XML]
<Simulation>
    ...
  <Models>
    <Code name="BouncingBall" subType = "OpenModelica">
      <executable>BouncingBall.exe</executable>
    </Code>
  </Models>
    ...
</Simulation>
\end{lstlisting}
\subsubsection{CSV Output}
The CSV files produced by OpenModelica model executables require adjustment before it may be read by RAVEN. 
The first few lines of original CSV output from the 
BouncingBall example is shown below:
\begin{lstlisting}
"time","h","v","der(h)","der(v)","v_new","foo","flying","impact",
0,1,0,0,-9.810000000000001,0,2,1,0,
  ...
\end{lstlisting}
RAVEN will not properly read this file as-generated for two reasons:
\begin{itemize}
  \item The variable names in the first line are each enclosed in double-quotes. 
  \item Each line has a trailing comma.
\end{itemize}
 The OpenModelica inteface will automatically remove the double-quotes and trailing commas through its implementation of the 
finalizeCodeOutput function.  
