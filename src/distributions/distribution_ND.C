/*
 * distribution_ND.C
 *
 *  Created on: Feb 6, 2014
 *      Author: alfoa
 *
 */

#include "distribution_ND.h"
#include <string>
#include <list>

#define throwError(msg) { std::cerr << "\n\n" << msg << "\n\n"; throw std::runtime_error("Error"); }

template<>
InputParameters validParams<distributionND>()
{
  InputParameters params = validParams<RavenObject>();
  params.addParam<double>("ProbabilityThreshold", 1.0, "Probability Threshold");
  params.addRequiredParam<std::string>("type","distribution type");
  params.addRequiredParam<std::string>("data_filename","Name of the file containing the data points to be interpolated");
  params.addParam<double>("PB_window_Low", 0.0, "Probability window lower bound");
  params.addParam<double>("PB_window_Up", 1.0, "Probability window upper bound");
  params.addRequiredParam<PbFunctionType>("function_type","PDF or CDF");
  params.registerBase("distributionND");
  return params;
}

class distributionND;

distributionND::distributionND(const std::string & name, InputParameters parameters):
      RavenObject(name,parameters)
{
   _type          = getParam<std::string>("type");
   _data_filename = getParam<std::string>("data_filename");
   _function_type = getParam<PbFunctionType>("function_type");
   _dis_parameters["ProbabilityThreshold"]  = getParam<double>("ProbabilityThreshold");
   _dis_parameters["PB_window_Low"] = getParam<double>("PB_window_Low");
   _dis_parameters["PB_window_Up"]  = getParam<double>("PB_window_Up");

   _checkStatus   = false;
}

distributionND::~distributionND(){
}

/*
 * CLASS ND DISTRIBUTION InverseWeight
 */

template<>
InputParameters validParams<MultiDimensionalInverseWeight>(){

   InputParameters params = validParams<distributionND>();
   params.addRequiredParam<double>("p", "Minkowski distance parameter");
   return params;

}

MultiDimensionalInverseWeight::MultiDimensionalInverseWeight(const std::string & name, InputParameters parameters):
    distributionND(name,parameters),
    BasicMultiDimensionalInverseWeight(getParam<std::string>("data_filename"),getParam<double>("p"))
{
}

MultiDimensionalInverseWeight::~MultiDimensionalInverseWeight()
{
}

/*
 * CLASS ND DISTRIBUTION MultivariateNormal
 */

template<>
InputParameters validParams<MultivariateNormal>(){

   InputParameters params = validParams<distributionND>();
   params.addRequiredParam<std::vector<double> >("mu", "Mu vector");
   params.addRequiredParam<std::vector<double> >("sigma", "Sigma vector");
   return params;

}

MultivariateNormal::MultivariateNormal(const std::string & name, InputParameters parameters):
    distributionND(name,parameters),
    BasicMultivariateNormal(getParam<std::string>("data_filename"),getParam<std::vector<double> >("mu"), getParam<std::vector<double> >("sigma"))
{
}

MultivariateNormal::~MultivariateNormal()
{
}


/*
 * CLASS ND DISTRIBUTION MultiDimensionalScatteredMS
 */

template<>
InputParameters validParams<MultiDimensionalScatteredMS>(){

   InputParameters params = validParams<distributionND>();
   params.addRequiredParam<double>("p", "Minkowski distance parameter");
   params.addRequiredParam<int>("precision", " ");
   return params;

}

MultiDimensionalScatteredMS::MultiDimensionalScatteredMS(const std::string & name, InputParameters parameters):
    distributionND(name,parameters),
    BasicMultiDimensionalScatteredMS(getParam<std::string>("data_filename"),getParam<double>("p"),getParam<int>("precision"))
{
}

MultiDimensionalScatteredMS::~MultiDimensionalScatteredMS()
{
}

/*
 * CLASS ND DISTRIBUTION MultiDimensionalCartesianSpline
 */

template<>
InputParameters validParams<MultiDimensionalCartesianSpline>(){

   InputParameters params = validParams<distributionND>();
   params.addRequiredParam<std::vector<double> >("alpha", "alpha");
   params.addRequiredParam<std::vector<double> >("beta", "beta");
   return params;

}

MultiDimensionalCartesianSpline::MultiDimensionalCartesianSpline(const std::string & name, InputParameters parameters):
    distributionND(name,parameters),
    BasicMultiDimensionalCartesianSpline(getParam<std::string>("data_filename"),getParam<std::vector<double> >("alpha"),getParam<std::vector<double> >("beta"))
{
}

MultiDimensionalCartesianSpline::~MultiDimensionalCartesianSpline()
{
}
